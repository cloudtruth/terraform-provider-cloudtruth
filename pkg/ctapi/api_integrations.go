/*
CloudTruth Management API

CloudTruth centralizes your configuration parameters and secrets making them easier to manage and use as a team.

API version: v1
Contact: support@cloudtruth.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ctapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// IntegrationsApiService IntegrationsApi service
type IntegrationsApiService service

type ApiIntegrationsAwsCreateRequest struct {
	ctx                  _context.Context
	ApiService           *IntegrationsApiService
	awsIntegrationCreate *AwsIntegrationCreate
}

func (r ApiIntegrationsAwsCreateRequest) AwsIntegrationCreate(awsIntegrationCreate AwsIntegrationCreate) ApiIntegrationsAwsCreateRequest {
	r.awsIntegrationCreate = &awsIntegrationCreate
	return r
}

func (r ApiIntegrationsAwsCreateRequest) Execute() (AwsIntegration, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsCreateExecute(r)
}

/*
IntegrationsAwsCreate Establishes an AWS Integration.

### Description ###

Establishes an AWS Integration for your CloudTruth organization.

### Pre-Conditions ###

- An AWS Integration for the account and role cannot already exist.
### Post-Conditions ###

- You must establish an IAM role and trust relationship based on the Role Name and the External ID.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntegrationsAwsCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsCreate(ctx _context.Context) ApiIntegrationsAwsCreateRequest {
	return ApiIntegrationsAwsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return AwsIntegration
func (a *IntegrationsApiService) IntegrationsAwsCreateExecute(r ApiIntegrationsAwsCreateRequest) (AwsIntegration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.awsIntegrationCreate == nil {
		return localVarReturnValue, nil, reportError("awsIntegrationCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsIntegrationCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsDestroyRequest struct {
	ctx        _context.Context
	ApiService *IntegrationsApiService
	id         string
	inUse      *string
}

// (Optional) Desired behavior if the integration has in-use values.  - &#x60;fail&#x60; will return HTTP error 409 if there are any values using the integration. - &#x60;leave&#x60; (default) will leave values in place and future queries may fail; you can control future value query behavior with the &#x60;lookup_error&#x60; query parameter on those requests. - &#x60;remove&#x60; will remove the all values using the integration when the integration is removed.
func (r ApiIntegrationsAwsDestroyRequest) InUse(inUse string) ApiIntegrationsAwsDestroyRequest {
	r.inUse = &inUse
	return r
}

func (r ApiIntegrationsAwsDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsDestroyExecute(r)
}

/*
IntegrationsAwsDestroy Delete an AWS integration.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsAwsDestroyRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsDestroy(ctx _context.Context, id string) ApiIntegrationsAwsDestroyRequest {
	return ApiIntegrationsAwsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAwsDestroyExecute(r ApiIntegrationsAwsDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.inUse != nil {
		localVarQueryParams.Add("in_use", parameterToString(*r.inUse, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAwsListRequest struct {
	ctx          _context.Context
	ApiService   *IntegrationsApiService
	awsAccountId *string
	awsRoleName  *string
	ordering     *string
	page         *int32
	pageSize     *int32
}

func (r ApiIntegrationsAwsListRequest) AwsAccountId(awsAccountId string) ApiIntegrationsAwsListRequest {
	r.awsAccountId = &awsAccountId
	return r
}
func (r ApiIntegrationsAwsListRequest) AwsRoleName(awsRoleName string) ApiIntegrationsAwsListRequest {
	r.awsRoleName = &awsRoleName
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAwsListRequest) Ordering(ordering string) ApiIntegrationsAwsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAwsListRequest) Page(page int32) ApiIntegrationsAwsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAwsListRequest) PageSize(pageSize int32) ApiIntegrationsAwsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsAwsListRequest) Execute() (PaginatedAwsIntegrationList, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsListExecute(r)
}

/*
IntegrationsAwsList Method for IntegrationsAwsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntegrationsAwsListRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsList(ctx _context.Context) ApiIntegrationsAwsListRequest {
	return ApiIntegrationsAwsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedAwsIntegrationList
func (a *IntegrationsApiService) IntegrationsAwsListExecute(r ApiIntegrationsAwsListRequest) (PaginatedAwsIntegrationList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedAwsIntegrationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.awsAccountId != nil {
		localVarQueryParams.Add("aws_account_id", parameterToString(*r.awsAccountId, ""))
	}
	if r.awsRoleName != nil {
		localVarQueryParams.Add("aws_role_name", parameterToString(*r.awsRoleName, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPartialUpdateRequest struct {
	ctx                   _context.Context
	ApiService            *IntegrationsApiService
	id                    string
	patchedAwsIntegration *PatchedAwsIntegration
}

func (r ApiIntegrationsAwsPartialUpdateRequest) PatchedAwsIntegration(patchedAwsIntegration PatchedAwsIntegration) ApiIntegrationsAwsPartialUpdateRequest {
	r.patchedAwsIntegration = &patchedAwsIntegration
	return r
}

func (r ApiIntegrationsAwsPartialUpdateRequest) Execute() (AwsIntegration, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPartialUpdateExecute(r)
}

/*
IntegrationsAwsPartialUpdate Method for IntegrationsAwsPartialUpdate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsAwsPartialUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPartialUpdate(ctx _context.Context, id string) ApiIntegrationsAwsPartialUpdateRequest {
	return ApiIntegrationsAwsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return AwsIntegration
func (a *IntegrationsApiService) IntegrationsAwsPartialUpdateExecute(r ApiIntegrationsAwsPartialUpdateRequest) (AwsIntegration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAwsIntegration
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsCreateRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awsPull          *AwsPull
}

func (r ApiIntegrationsAwsPullsCreateRequest) AwsPull(awsPull AwsPull) ApiIntegrationsAwsPullsCreateRequest {
	r.awsPull = &awsPull
	return r
}

func (r ApiIntegrationsAwsPullsCreateRequest) Execute() (AwsPull, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPullsCreateExecute(r)
}

/*
IntegrationsAwsPullsCreate Method for IntegrationsAwsPullsCreate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @return ApiIntegrationsAwsPullsCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsCreate(ctx _context.Context, awsintegrationPk string) ApiIntegrationsAwsPullsCreateRequest {
	return ApiIntegrationsAwsPullsCreateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
	}
}

// Execute executes the request
//  @return AwsPull
func (a *IntegrationsApiService) IntegrationsAwsPullsCreateExecute(r ApiIntegrationsAwsPullsCreateRequest) (AwsPull, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.awsPull == nil {
		return localVarReturnValue, nil, reportError("awsPull is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsPull
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsDestroyRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
}

func (r ApiIntegrationsAwsPullsDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPullsDestroyExecute(r)
}

/*
IntegrationsAwsPullsDestroy Method for IntegrationsAwsPullsDestroy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPullsDestroyRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsDestroy(ctx _context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPullsDestroyRequest {
	return ApiIntegrationsAwsPullsDestroyRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAwsPullsDestroyExecute(r ApiIntegrationsAwsPullsDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsListRequest struct {
	ctx                  _context.Context
	ApiService           *IntegrationsApiService
	awsintegrationPk     string
	descriptionIcontains *string
	name                 *string
	nameIcontains        *string
	ordering             *string
	page                 *int32
	pageSize             *int32
}

func (r ApiIntegrationsAwsPullsListRequest) DescriptionIcontains(descriptionIcontains string) ApiIntegrationsAwsPullsListRequest {
	r.descriptionIcontains = &descriptionIcontains
	return r
}
func (r ApiIntegrationsAwsPullsListRequest) Name(name string) ApiIntegrationsAwsPullsListRequest {
	r.name = &name
	return r
}
func (r ApiIntegrationsAwsPullsListRequest) NameIcontains(nameIcontains string) ApiIntegrationsAwsPullsListRequest {
	r.nameIcontains = &nameIcontains
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAwsPullsListRequest) Ordering(ordering string) ApiIntegrationsAwsPullsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAwsPullsListRequest) Page(page int32) ApiIntegrationsAwsPullsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAwsPullsListRequest) PageSize(pageSize int32) ApiIntegrationsAwsPullsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsAwsPullsListRequest) Execute() (PaginatedAwsPullList, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPullsListExecute(r)
}

/*
IntegrationsAwsPullsList Method for IntegrationsAwsPullsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @return ApiIntegrationsAwsPullsListRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsList(ctx _context.Context, awsintegrationPk string) ApiIntegrationsAwsPullsListRequest {
	return ApiIntegrationsAwsPullsListRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
	}
}

// Execute executes the request
//  @return PaginatedAwsPullList
func (a *IntegrationsApiService) IntegrationsAwsPullsListExecute(r ApiIntegrationsAwsPullsListRequest) (PaginatedAwsPullList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedAwsPullList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.descriptionIcontains != nil {
		localVarQueryParams.Add("description__icontains", parameterToString(*r.descriptionIcontains, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameIcontains != nil {
		localVarQueryParams.Add("name__icontains", parameterToString(*r.nameIcontains, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsPartialUpdateRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
	patchedAwsPull   *PatchedAwsPull
}

func (r ApiIntegrationsAwsPullsPartialUpdateRequest) PatchedAwsPull(patchedAwsPull PatchedAwsPull) ApiIntegrationsAwsPullsPartialUpdateRequest {
	r.patchedAwsPull = &patchedAwsPull
	return r
}

func (r ApiIntegrationsAwsPullsPartialUpdateRequest) Execute() (AwsPull, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPullsPartialUpdateExecute(r)
}

/*
IntegrationsAwsPullsPartialUpdate Method for IntegrationsAwsPullsPartialUpdate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPullsPartialUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsPartialUpdate(ctx _context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPullsPartialUpdateRequest {
	return ApiIntegrationsAwsPullsPartialUpdateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPull
func (a *IntegrationsApiService) IntegrationsAwsPullsPartialUpdateExecute(r ApiIntegrationsAwsPullsPartialUpdateRequest) (AwsPull, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAwsPull
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsRetrieveRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
}

func (r ApiIntegrationsAwsPullsRetrieveRequest) Execute() (AwsPull, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPullsRetrieveExecute(r)
}

/*
IntegrationsAwsPullsRetrieve Method for IntegrationsAwsPullsRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPullsRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsRetrieve(ctx _context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPullsRetrieveRequest {
	return ApiIntegrationsAwsPullsRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPull
func (a *IntegrationsApiService) IntegrationsAwsPullsRetrieveExecute(r ApiIntegrationsAwsPullsRetrieveRequest) (AwsPull, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsSyncCreateRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
	awsPull          *AwsPull
}

func (r ApiIntegrationsAwsPullsSyncCreateRequest) AwsPull(awsPull AwsPull) ApiIntegrationsAwsPullsSyncCreateRequest {
	r.awsPull = &awsPull
	return r
}

func (r ApiIntegrationsAwsPullsSyncCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPullsSyncCreateExecute(r)
}

/*
IntegrationsAwsPullsSyncCreate Method for IntegrationsAwsPullsSyncCreate

Enqueue a pull synchronization task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPullsSyncCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsSyncCreate(ctx _context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPullsSyncCreateRequest {
	return ApiIntegrationsAwsPullsSyncCreateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAwsPullsSyncCreateExecute(r ApiIntegrationsAwsPullsSyncCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsSyncCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{id}/sync/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.awsPull == nil {
		return nil, reportError("awsPull is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsPull
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsTasksListRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awspullPk        string
	modifiedAt       *time.Time
	modifiedAtGte    *time.Time
	modifiedAtLte    *time.Time
	ordering         *string
	page             *int32
	pageSize         *int32
	state            *string
}

func (r ApiIntegrationsAwsPullsTasksListRequest) ModifiedAt(modifiedAt time.Time) ApiIntegrationsAwsPullsTasksListRequest {
	r.modifiedAt = &modifiedAt
	return r
}
func (r ApiIntegrationsAwsPullsTasksListRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiIntegrationsAwsPullsTasksListRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}
func (r ApiIntegrationsAwsPullsTasksListRequest) ModifiedAtLte(modifiedAtLte time.Time) ApiIntegrationsAwsPullsTasksListRequest {
	r.modifiedAtLte = &modifiedAtLte
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAwsPullsTasksListRequest) Ordering(ordering string) ApiIntegrationsAwsPullsTasksListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAwsPullsTasksListRequest) Page(page int32) ApiIntegrationsAwsPullsTasksListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAwsPullsTasksListRequest) PageSize(pageSize int32) ApiIntegrationsAwsPullsTasksListRequest {
	r.pageSize = &pageSize
	return r
}

// The current state of this task.
func (r ApiIntegrationsAwsPullsTasksListRequest) State(state string) ApiIntegrationsAwsPullsTasksListRequest {
	r.state = &state
	return r
}

func (r ApiIntegrationsAwsPullsTasksListRequest) Execute() (PaginatedAwsPushTaskList, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPullsTasksListExecute(r)
}

/*
IntegrationsAwsPullsTasksList Method for IntegrationsAwsPullsTasksList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspullPk
 @return ApiIntegrationsAwsPullsTasksListRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksList(ctx _context.Context, awsintegrationPk string, awspullPk string) ApiIntegrationsAwsPullsTasksListRequest {
	return ApiIntegrationsAwsPullsTasksListRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspullPk:        awspullPk,
	}
}

// Execute executes the request
//  @return PaginatedAwsPushTaskList
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksListExecute(r ApiIntegrationsAwsPullsTasksListRequest) (PaginatedAwsPushTaskList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedAwsPushTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsTasksList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{awspull_pk}/tasks/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspull_pk"+"}", _neturl.PathEscape(parameterToString(r.awspullPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.modifiedAt != nil {
		localVarQueryParams.Add("modified_at", parameterToString(*r.modifiedAt, ""))
	}
	if r.modifiedAtGte != nil {
		localVarQueryParams.Add("modified_at__gte", parameterToString(*r.modifiedAtGte, ""))
	}
	if r.modifiedAtLte != nil {
		localVarQueryParams.Add("modified_at__lte", parameterToString(*r.modifiedAtLte, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsTasksRetrieveRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awspullPk        string
	id               string
}

func (r ApiIntegrationsAwsPullsTasksRetrieveRequest) Execute() (AwsPushTask, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPullsTasksRetrieveExecute(r)
}

/*
IntegrationsAwsPullsTasksRetrieve Method for IntegrationsAwsPullsTasksRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspullPk
 @param id
 @return ApiIntegrationsAwsPullsTasksRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksRetrieve(ctx _context.Context, awsintegrationPk string, awspullPk string, id string) ApiIntegrationsAwsPullsTasksRetrieveRequest {
	return ApiIntegrationsAwsPullsTasksRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspullPk:        awspullPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPushTask
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksRetrieveExecute(r ApiIntegrationsAwsPullsTasksRetrieveRequest) (AwsPushTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsPushTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsTasksRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{awspull_pk}/tasks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspull_pk"+"}", _neturl.PathEscape(parameterToString(r.awspullPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsTasksStepsListRequest struct {
	ctx                _context.Context
	ApiService         *IntegrationsApiService
	awsintegrationPk   string
	awspullPk          string
	awspulltaskPk      string
	fqn                *string
	modifiedAt         *time.Time
	modifiedAtGte      *time.Time
	modifiedAtLte      *time.Time
	operation          *string
	ordering           *string
	page               *int32
	pageSize           *int32
	success            *bool
	venueId            *string
	venueIdIcontains   *string
	venueName          *string
	venueNameIcontains *string
}

func (r ApiIntegrationsAwsPullsTasksStepsListRequest) Fqn(fqn string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.fqn = &fqn
	return r
}
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) ModifiedAt(modifiedAt time.Time) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.modifiedAt = &modifiedAt
	return r
}
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) ModifiedAtLte(modifiedAtLte time.Time) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.modifiedAtLte = &modifiedAtLte
	return r
}

// The operation performed, if any.  When the operation is an update, there may be additional details in the success_detail field to describe the change.  When the project is filled in but the environment and parameterare not, the operation is on the project.  When the environmentis filled in but the project and parameter are not, the operationis on the environment.  When the project and parameter are filledin but the environment is not, the operation is on the parameter.When all three are filled in, the operation is on the value ofthe parameter of the project in the specified environment.
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) Operation(operation string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.operation = &operation
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) Ordering(ordering string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) Page(page int32) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) PageSize(pageSize int32) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) Success(success bool) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.success = &success
	return r
}
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) VenueId(venueId string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.venueId = &venueId
	return r
}
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) VenueIdIcontains(venueIdIcontains string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.venueIdIcontains = &venueIdIcontains
	return r
}
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) VenueName(venueName string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.venueName = &venueName
	return r
}
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) VenueNameIcontains(venueNameIcontains string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.venueNameIcontains = &venueNameIcontains
	return r
}

func (r ApiIntegrationsAwsPullsTasksStepsListRequest) Execute() (PaginatedAwsPushTaskStepList, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPullsTasksStepsListExecute(r)
}

/*
IntegrationsAwsPullsTasksStepsList Method for IntegrationsAwsPullsTasksStepsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspullPk
 @param awspulltaskPk
 @return ApiIntegrationsAwsPullsTasksStepsListRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksStepsList(ctx _context.Context, awsintegrationPk string, awspullPk string, awspulltaskPk string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	return ApiIntegrationsAwsPullsTasksStepsListRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspullPk:        awspullPk,
		awspulltaskPk:    awspulltaskPk,
	}
}

// Execute executes the request
//  @return PaginatedAwsPushTaskStepList
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksStepsListExecute(r ApiIntegrationsAwsPullsTasksStepsListRequest) (PaginatedAwsPushTaskStepList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedAwsPushTaskStepList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsTasksStepsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{awspull_pk}/tasks/{awspulltask_pk}/steps/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspull_pk"+"}", _neturl.PathEscape(parameterToString(r.awspullPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspulltask_pk"+"}", _neturl.PathEscape(parameterToString(r.awspulltaskPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fqn != nil {
		localVarQueryParams.Add("fqn", parameterToString(*r.fqn, ""))
	}
	if r.modifiedAt != nil {
		localVarQueryParams.Add("modified_at", parameterToString(*r.modifiedAt, ""))
	}
	if r.modifiedAtGte != nil {
		localVarQueryParams.Add("modified_at__gte", parameterToString(*r.modifiedAtGte, ""))
	}
	if r.modifiedAtLte != nil {
		localVarQueryParams.Add("modified_at__lte", parameterToString(*r.modifiedAtLte, ""))
	}
	if r.operation != nil {
		localVarQueryParams.Add("operation", parameterToString(*r.operation, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.success != nil {
		localVarQueryParams.Add("success", parameterToString(*r.success, ""))
	}
	if r.venueId != nil {
		localVarQueryParams.Add("venue_id", parameterToString(*r.venueId, ""))
	}
	if r.venueIdIcontains != nil {
		localVarQueryParams.Add("venue_id__icontains", parameterToString(*r.venueIdIcontains, ""))
	}
	if r.venueName != nil {
		localVarQueryParams.Add("venue_name", parameterToString(*r.venueName, ""))
	}
	if r.venueNameIcontains != nil {
		localVarQueryParams.Add("venue_name__icontains", parameterToString(*r.venueNameIcontains, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsTasksStepsRetrieveRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awspullPk        string
	awspulltaskPk    string
	id               string
}

func (r ApiIntegrationsAwsPullsTasksStepsRetrieveRequest) Execute() (AwsPushTaskStep, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPullsTasksStepsRetrieveExecute(r)
}

/*
IntegrationsAwsPullsTasksStepsRetrieve Method for IntegrationsAwsPullsTasksStepsRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspullPk
 @param awspulltaskPk
 @param id
 @return ApiIntegrationsAwsPullsTasksStepsRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksStepsRetrieve(ctx _context.Context, awsintegrationPk string, awspullPk string, awspulltaskPk string, id string) ApiIntegrationsAwsPullsTasksStepsRetrieveRequest {
	return ApiIntegrationsAwsPullsTasksStepsRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspullPk:        awspullPk,
		awspulltaskPk:    awspulltaskPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPushTaskStep
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksStepsRetrieveExecute(r ApiIntegrationsAwsPullsTasksStepsRetrieveRequest) (AwsPushTaskStep, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsPushTaskStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsTasksStepsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{awspull_pk}/tasks/{awspulltask_pk}/steps/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspull_pk"+"}", _neturl.PathEscape(parameterToString(r.awspullPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspulltask_pk"+"}", _neturl.PathEscape(parameterToString(r.awspulltaskPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsUpdateRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
	awsPull          *AwsPull
}

func (r ApiIntegrationsAwsPullsUpdateRequest) AwsPull(awsPull AwsPull) ApiIntegrationsAwsPullsUpdateRequest {
	r.awsPull = &awsPull
	return r
}

func (r ApiIntegrationsAwsPullsUpdateRequest) Execute() (AwsPull, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPullsUpdateExecute(r)
}

/*
IntegrationsAwsPullsUpdate Method for IntegrationsAwsPullsUpdate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPullsUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsUpdate(ctx _context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPullsUpdateRequest {
	return ApiIntegrationsAwsPullsUpdateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPull
func (a *IntegrationsApiService) IntegrationsAwsPullsUpdateExecute(r ApiIntegrationsAwsPullsUpdateRequest) (AwsPull, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.awsPull == nil {
		return localVarReturnValue, nil, reportError("awsPull is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsPull
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesCreateRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awsPush          *AwsPush
}

func (r ApiIntegrationsAwsPushesCreateRequest) AwsPush(awsPush AwsPush) ApiIntegrationsAwsPushesCreateRequest {
	r.awsPush = &awsPush
	return r
}

func (r ApiIntegrationsAwsPushesCreateRequest) Execute() (AwsPush, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPushesCreateExecute(r)
}

/*
IntegrationsAwsPushesCreate Method for IntegrationsAwsPushesCreate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @return ApiIntegrationsAwsPushesCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesCreate(ctx _context.Context, awsintegrationPk string) ApiIntegrationsAwsPushesCreateRequest {
	return ApiIntegrationsAwsPushesCreateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
	}
}

// Execute executes the request
//  @return AwsPush
func (a *IntegrationsApiService) IntegrationsAwsPushesCreateExecute(r ApiIntegrationsAwsPushesCreateRequest) (AwsPush, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsPush
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.awsPush == nil {
		return localVarReturnValue, nil, reportError("awsPush is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsPush
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesDestroyRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
}

func (r ApiIntegrationsAwsPushesDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPushesDestroyExecute(r)
}

/*
IntegrationsAwsPushesDestroy Method for IntegrationsAwsPushesDestroy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPushesDestroyRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesDestroy(ctx _context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPushesDestroyRequest {
	return ApiIntegrationsAwsPushesDestroyRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAwsPushesDestroyExecute(r ApiIntegrationsAwsPushesDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesListRequest struct {
	ctx                  _context.Context
	ApiService           *IntegrationsApiService
	awsintegrationPk     string
	descriptionIcontains *string
	name                 *string
	nameIcontains        *string
	ordering             *string
	page                 *int32
	pageSize             *int32
}

func (r ApiIntegrationsAwsPushesListRequest) DescriptionIcontains(descriptionIcontains string) ApiIntegrationsAwsPushesListRequest {
	r.descriptionIcontains = &descriptionIcontains
	return r
}
func (r ApiIntegrationsAwsPushesListRequest) Name(name string) ApiIntegrationsAwsPushesListRequest {
	r.name = &name
	return r
}
func (r ApiIntegrationsAwsPushesListRequest) NameIcontains(nameIcontains string) ApiIntegrationsAwsPushesListRequest {
	r.nameIcontains = &nameIcontains
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAwsPushesListRequest) Ordering(ordering string) ApiIntegrationsAwsPushesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAwsPushesListRequest) Page(page int32) ApiIntegrationsAwsPushesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAwsPushesListRequest) PageSize(pageSize int32) ApiIntegrationsAwsPushesListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsAwsPushesListRequest) Execute() (PaginatedAwsPushList, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPushesListExecute(r)
}

/*
IntegrationsAwsPushesList Method for IntegrationsAwsPushesList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @return ApiIntegrationsAwsPushesListRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesList(ctx _context.Context, awsintegrationPk string) ApiIntegrationsAwsPushesListRequest {
	return ApiIntegrationsAwsPushesListRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
	}
}

// Execute executes the request
//  @return PaginatedAwsPushList
func (a *IntegrationsApiService) IntegrationsAwsPushesListExecute(r ApiIntegrationsAwsPushesListRequest) (PaginatedAwsPushList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedAwsPushList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.descriptionIcontains != nil {
		localVarQueryParams.Add("description__icontains", parameterToString(*r.descriptionIcontains, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameIcontains != nil {
		localVarQueryParams.Add("name__icontains", parameterToString(*r.nameIcontains, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesPartialUpdateRequest struct {
	ctx                  _context.Context
	ApiService           *IntegrationsApiService
	awsintegrationPk     string
	id                   string
	patchedAwsPushUpdate *PatchedAwsPushUpdate
}

func (r ApiIntegrationsAwsPushesPartialUpdateRequest) PatchedAwsPushUpdate(patchedAwsPushUpdate PatchedAwsPushUpdate) ApiIntegrationsAwsPushesPartialUpdateRequest {
	r.patchedAwsPushUpdate = &patchedAwsPushUpdate
	return r
}

func (r ApiIntegrationsAwsPushesPartialUpdateRequest) Execute() (AwsPushUpdate, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPushesPartialUpdateExecute(r)
}

/*
IntegrationsAwsPushesPartialUpdate Method for IntegrationsAwsPushesPartialUpdate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPushesPartialUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesPartialUpdate(ctx _context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPushesPartialUpdateRequest {
	return ApiIntegrationsAwsPushesPartialUpdateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPushUpdate
func (a *IntegrationsApiService) IntegrationsAwsPushesPartialUpdateExecute(r ApiIntegrationsAwsPushesPartialUpdateRequest) (AwsPushUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsPushUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAwsPushUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesRetrieveRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
}

func (r ApiIntegrationsAwsPushesRetrieveRequest) Execute() (AwsPush, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPushesRetrieveExecute(r)
}

/*
IntegrationsAwsPushesRetrieve Method for IntegrationsAwsPushesRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPushesRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesRetrieve(ctx _context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPushesRetrieveRequest {
	return ApiIntegrationsAwsPushesRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPush
func (a *IntegrationsApiService) IntegrationsAwsPushesRetrieveExecute(r ApiIntegrationsAwsPushesRetrieveRequest) (AwsPush, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsPush
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesSyncCreateRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
	awsPush          *AwsPush
}

func (r ApiIntegrationsAwsPushesSyncCreateRequest) AwsPush(awsPush AwsPush) ApiIntegrationsAwsPushesSyncCreateRequest {
	r.awsPush = &awsPush
	return r
}

func (r ApiIntegrationsAwsPushesSyncCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPushesSyncCreateExecute(r)
}

/*
IntegrationsAwsPushesSyncCreate Method for IntegrationsAwsPushesSyncCreate

Enqueue a push synchronization task.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPushesSyncCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesSyncCreate(ctx _context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPushesSyncCreateRequest {
	return ApiIntegrationsAwsPushesSyncCreateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAwsPushesSyncCreateExecute(r ApiIntegrationsAwsPushesSyncCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesSyncCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{id}/sync/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.awsPush == nil {
		return nil, reportError("awsPush is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsPush
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesTasksListRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awspushPk        string
	modifiedAt       *time.Time
	modifiedAtGte    *time.Time
	modifiedAtLte    *time.Time
	ordering         *string
	page             *int32
	pageSize         *int32
	state            *string
}

func (r ApiIntegrationsAwsPushesTasksListRequest) ModifiedAt(modifiedAt time.Time) ApiIntegrationsAwsPushesTasksListRequest {
	r.modifiedAt = &modifiedAt
	return r
}
func (r ApiIntegrationsAwsPushesTasksListRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiIntegrationsAwsPushesTasksListRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}
func (r ApiIntegrationsAwsPushesTasksListRequest) ModifiedAtLte(modifiedAtLte time.Time) ApiIntegrationsAwsPushesTasksListRequest {
	r.modifiedAtLte = &modifiedAtLte
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAwsPushesTasksListRequest) Ordering(ordering string) ApiIntegrationsAwsPushesTasksListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAwsPushesTasksListRequest) Page(page int32) ApiIntegrationsAwsPushesTasksListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAwsPushesTasksListRequest) PageSize(pageSize int32) ApiIntegrationsAwsPushesTasksListRequest {
	r.pageSize = &pageSize
	return r
}

// The current state of this task.
func (r ApiIntegrationsAwsPushesTasksListRequest) State(state string) ApiIntegrationsAwsPushesTasksListRequest {
	r.state = &state
	return r
}

func (r ApiIntegrationsAwsPushesTasksListRequest) Execute() (PaginatedAwsPushTaskList, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPushesTasksListExecute(r)
}

/*
IntegrationsAwsPushesTasksList Method for IntegrationsAwsPushesTasksList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspushPk
 @return ApiIntegrationsAwsPushesTasksListRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksList(ctx _context.Context, awsintegrationPk string, awspushPk string) ApiIntegrationsAwsPushesTasksListRequest {
	return ApiIntegrationsAwsPushesTasksListRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspushPk:        awspushPk,
	}
}

// Execute executes the request
//  @return PaginatedAwsPushTaskList
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksListExecute(r ApiIntegrationsAwsPushesTasksListRequest) (PaginatedAwsPushTaskList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedAwsPushTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesTasksList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{awspush_pk}/tasks/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspush_pk"+"}", _neturl.PathEscape(parameterToString(r.awspushPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.modifiedAt != nil {
		localVarQueryParams.Add("modified_at", parameterToString(*r.modifiedAt, ""))
	}
	if r.modifiedAtGte != nil {
		localVarQueryParams.Add("modified_at__gte", parameterToString(*r.modifiedAtGte, ""))
	}
	if r.modifiedAtLte != nil {
		localVarQueryParams.Add("modified_at__lte", parameterToString(*r.modifiedAtLte, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesTasksRetrieveRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awspushPk        string
	id               string
}

func (r ApiIntegrationsAwsPushesTasksRetrieveRequest) Execute() (AwsPushTask, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPushesTasksRetrieveExecute(r)
}

/*
IntegrationsAwsPushesTasksRetrieve Method for IntegrationsAwsPushesTasksRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspushPk
 @param id
 @return ApiIntegrationsAwsPushesTasksRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksRetrieve(ctx _context.Context, awsintegrationPk string, awspushPk string, id string) ApiIntegrationsAwsPushesTasksRetrieveRequest {
	return ApiIntegrationsAwsPushesTasksRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspushPk:        awspushPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPushTask
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksRetrieveExecute(r ApiIntegrationsAwsPushesTasksRetrieveRequest) (AwsPushTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsPushTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesTasksRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{awspush_pk}/tasks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspush_pk"+"}", _neturl.PathEscape(parameterToString(r.awspushPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesTasksStepsListRequest struct {
	ctx                _context.Context
	ApiService         *IntegrationsApiService
	awsintegrationPk   string
	awspushPk          string
	awspushtaskPk      string
	fqn                *string
	modifiedAt         *time.Time
	modifiedAtGte      *time.Time
	modifiedAtLte      *time.Time
	operation          *string
	ordering           *string
	page               *int32
	pageSize           *int32
	success            *bool
	venueId            *string
	venueIdIcontains   *string
	venueName          *string
	venueNameIcontains *string
}

func (r ApiIntegrationsAwsPushesTasksStepsListRequest) Fqn(fqn string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.fqn = &fqn
	return r
}
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) ModifiedAt(modifiedAt time.Time) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.modifiedAt = &modifiedAt
	return r
}
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) ModifiedAtLte(modifiedAtLte time.Time) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.modifiedAtLte = &modifiedAtLte
	return r
}

// The operation performed, if any.  When the operation is an update, there may be additional details in the success_detail field to describe the change.  When the project is filled in but the environment and parameterare not, the operation is on the project.  When the environmentis filled in but the project and parameter are not, the operationis on the environment.  When the project and parameter are filledin but the environment is not, the operation is on the parameter.When all three are filled in, the operation is on the value ofthe parameter of the project in the specified environment.
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) Operation(operation string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.operation = &operation
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) Ordering(ordering string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) Page(page int32) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) PageSize(pageSize int32) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) Success(success bool) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.success = &success
	return r
}
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) VenueId(venueId string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.venueId = &venueId
	return r
}
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) VenueIdIcontains(venueIdIcontains string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.venueIdIcontains = &venueIdIcontains
	return r
}
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) VenueName(venueName string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.venueName = &venueName
	return r
}
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) VenueNameIcontains(venueNameIcontains string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.venueNameIcontains = &venueNameIcontains
	return r
}

func (r ApiIntegrationsAwsPushesTasksStepsListRequest) Execute() (PaginatedAwsPushTaskStepList, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPushesTasksStepsListExecute(r)
}

/*
IntegrationsAwsPushesTasksStepsList Method for IntegrationsAwsPushesTasksStepsList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspushPk
 @param awspushtaskPk
 @return ApiIntegrationsAwsPushesTasksStepsListRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksStepsList(ctx _context.Context, awsintegrationPk string, awspushPk string, awspushtaskPk string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	return ApiIntegrationsAwsPushesTasksStepsListRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspushPk:        awspushPk,
		awspushtaskPk:    awspushtaskPk,
	}
}

// Execute executes the request
//  @return PaginatedAwsPushTaskStepList
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksStepsListExecute(r ApiIntegrationsAwsPushesTasksStepsListRequest) (PaginatedAwsPushTaskStepList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedAwsPushTaskStepList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesTasksStepsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{awspush_pk}/tasks/{awspushtask_pk}/steps/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspush_pk"+"}", _neturl.PathEscape(parameterToString(r.awspushPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspushtask_pk"+"}", _neturl.PathEscape(parameterToString(r.awspushtaskPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fqn != nil {
		localVarQueryParams.Add("fqn", parameterToString(*r.fqn, ""))
	}
	if r.modifiedAt != nil {
		localVarQueryParams.Add("modified_at", parameterToString(*r.modifiedAt, ""))
	}
	if r.modifiedAtGte != nil {
		localVarQueryParams.Add("modified_at__gte", parameterToString(*r.modifiedAtGte, ""))
	}
	if r.modifiedAtLte != nil {
		localVarQueryParams.Add("modified_at__lte", parameterToString(*r.modifiedAtLte, ""))
	}
	if r.operation != nil {
		localVarQueryParams.Add("operation", parameterToString(*r.operation, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.success != nil {
		localVarQueryParams.Add("success", parameterToString(*r.success, ""))
	}
	if r.venueId != nil {
		localVarQueryParams.Add("venue_id", parameterToString(*r.venueId, ""))
	}
	if r.venueIdIcontains != nil {
		localVarQueryParams.Add("venue_id__icontains", parameterToString(*r.venueIdIcontains, ""))
	}
	if r.venueName != nil {
		localVarQueryParams.Add("venue_name", parameterToString(*r.venueName, ""))
	}
	if r.venueNameIcontains != nil {
		localVarQueryParams.Add("venue_name__icontains", parameterToString(*r.venueNameIcontains, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesTasksStepsRetrieveRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awspushPk        string
	awspushtaskPk    string
	id               string
}

func (r ApiIntegrationsAwsPushesTasksStepsRetrieveRequest) Execute() (AwsPushTaskStep, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPushesTasksStepsRetrieveExecute(r)
}

/*
IntegrationsAwsPushesTasksStepsRetrieve Method for IntegrationsAwsPushesTasksStepsRetrieve

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspushPk
 @param awspushtaskPk
 @param id
 @return ApiIntegrationsAwsPushesTasksStepsRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksStepsRetrieve(ctx _context.Context, awsintegrationPk string, awspushPk string, awspushtaskPk string, id string) ApiIntegrationsAwsPushesTasksStepsRetrieveRequest {
	return ApiIntegrationsAwsPushesTasksStepsRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspushPk:        awspushPk,
		awspushtaskPk:    awspushtaskPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPushTaskStep
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksStepsRetrieveExecute(r ApiIntegrationsAwsPushesTasksStepsRetrieveRequest) (AwsPushTaskStep, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsPushTaskStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesTasksStepsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{awspush_pk}/tasks/{awspushtask_pk}/steps/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspush_pk"+"}", _neturl.PathEscape(parameterToString(r.awspushPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspushtask_pk"+"}", _neturl.PathEscape(parameterToString(r.awspushtaskPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesUpdateRequest struct {
	ctx              _context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
	awsPushUpdate    *AwsPushUpdate
}

func (r ApiIntegrationsAwsPushesUpdateRequest) AwsPushUpdate(awsPushUpdate AwsPushUpdate) ApiIntegrationsAwsPushesUpdateRequest {
	r.awsPushUpdate = &awsPushUpdate
	return r
}

func (r ApiIntegrationsAwsPushesUpdateRequest) Execute() (AwsPushUpdate, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsPushesUpdateExecute(r)
}

/*
IntegrationsAwsPushesUpdate Method for IntegrationsAwsPushesUpdate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPushesUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesUpdate(ctx _context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPushesUpdateRequest {
	return ApiIntegrationsAwsPushesUpdateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPushUpdate
func (a *IntegrationsApiService) IntegrationsAwsPushesUpdateExecute(r ApiIntegrationsAwsPushesUpdateRequest) (AwsPushUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsPushUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", _neturl.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.awsPushUpdate == nil {
		return localVarReturnValue, nil, reportError("awsPushUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsPushUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsRetrieveRequest struct {
	ctx           _context.Context
	ApiService    *IntegrationsApiService
	id            string
	refreshStatus *bool
}

// Trigger a refresh of the integration status before returning the details.
func (r ApiIntegrationsAwsRetrieveRequest) RefreshStatus(refreshStatus bool) ApiIntegrationsAwsRetrieveRequest {
	r.refreshStatus = &refreshStatus
	return r
}

func (r ApiIntegrationsAwsRetrieveRequest) Execute() (AwsIntegration, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsRetrieveExecute(r)
}

/*
IntegrationsAwsRetrieve Get details of an AWS Integration.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsAwsRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsRetrieve(ctx _context.Context, id string) ApiIntegrationsAwsRetrieveRequest {
	return ApiIntegrationsAwsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return AwsIntegration
func (a *IntegrationsApiService) IntegrationsAwsRetrieveExecute(r ApiIntegrationsAwsRetrieveRequest) (AwsIntegration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refreshStatus != nil {
		localVarQueryParams.Add("refresh_status", parameterToString(*r.refreshStatus, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsUpdateRequest struct {
	ctx            _context.Context
	ApiService     *IntegrationsApiService
	id             string
	awsIntegration *AwsIntegration
}

func (r ApiIntegrationsAwsUpdateRequest) AwsIntegration(awsIntegration AwsIntegration) ApiIntegrationsAwsUpdateRequest {
	r.awsIntegration = &awsIntegration
	return r
}

func (r ApiIntegrationsAwsUpdateRequest) Execute() (AwsIntegration, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsAwsUpdateExecute(r)
}

/*
IntegrationsAwsUpdate Method for IntegrationsAwsUpdate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsAwsUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsUpdate(ctx _context.Context, id string) ApiIntegrationsAwsUpdateRequest {
	return ApiIntegrationsAwsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return AwsIntegration
func (a *IntegrationsApiService) IntegrationsAwsUpdateExecute(r ApiIntegrationsAwsUpdateRequest) (AwsIntegration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AwsIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.awsIntegration == nil {
		return localVarReturnValue, nil, reportError("awsIntegration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsIntegration
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsExploreListRequest struct {
	ctx        _context.Context
	ApiService *IntegrationsApiService
	fqn        *string
	ordering   *string
	page       *int32
	pageSize   *int32
}

// FQN (URL-like) for third-party integration.
func (r ApiIntegrationsExploreListRequest) Fqn(fqn string) ApiIntegrationsExploreListRequest {
	r.fqn = &fqn
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsExploreListRequest) Ordering(ordering string) ApiIntegrationsExploreListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsExploreListRequest) Page(page int32) ApiIntegrationsExploreListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsExploreListRequest) PageSize(pageSize int32) ApiIntegrationsExploreListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsExploreListRequest) Execute() (PaginatedIntegrationExplorerList, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsExploreListExecute(r)
}

/*
IntegrationsExploreList Retrieve third-party integration data for the specified FQN.

### Description ###

Queries a third-party integration to retrieve the data specified by the FQN.

You can start exploring by not specifying an 'fqn', which will return a list of FQNs for the existing third-party integrations. Third-party integrations can be configured via the Integrations section of the web application.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntegrationsExploreListRequest
*/
func (a *IntegrationsApiService) IntegrationsExploreList(ctx _context.Context) ApiIntegrationsExploreListRequest {
	return ApiIntegrationsExploreListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedIntegrationExplorerList
func (a *IntegrationsApiService) IntegrationsExploreListExecute(r ApiIntegrationsExploreListRequest) (PaginatedIntegrationExplorerList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedIntegrationExplorerList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsExploreList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/explore/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fqn != nil {
		localVarQueryParams.Add("fqn", parameterToString(*r.fqn, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsGithubCreateRequest struct {
	ctx                     _context.Context
	ApiService              *IntegrationsApiService
	gitHubIntegrationCreate *GitHubIntegrationCreate
}

func (r ApiIntegrationsGithubCreateRequest) GitHubIntegrationCreate(gitHubIntegrationCreate GitHubIntegrationCreate) ApiIntegrationsGithubCreateRequest {
	r.gitHubIntegrationCreate = &gitHubIntegrationCreate
	return r
}

func (r ApiIntegrationsGithubCreateRequest) Execute() (GitHubIntegration, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsGithubCreateExecute(r)
}

/*
IntegrationsGithubCreate Establishes a GitHub Integration.

### Description ###

Establishes a GitHub Integration in your CloudTruth organization.

### Pre-Conditions ###

- The user must be an Administrator or Owner of your organization.
- A GitHub Integration with the `installation_id` cannot
already exist in this organization.
- The user must first install the CloudTruth GitHub Application in
their GitHub organization and obtain the `installation_id` of the
application in order to create the integration.

### Initiating the GitHub Application Installation ###

- Go to `https://github.com/apps/GITHUB_APP_NAME/installations/new?state=<bearer_token>`
- On successful installation the browser will return to
`https://APP_URL/app_setup/github` (configured in ctops/bin/github*)
and provide the `installation_id` in the URI.
- POST to this api to verify and establish the integration.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntegrationsGithubCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubCreate(ctx _context.Context) ApiIntegrationsGithubCreateRequest {
	return ApiIntegrationsGithubCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GitHubIntegration
func (a *IntegrationsApiService) IntegrationsGithubCreateExecute(r ApiIntegrationsGithubCreateRequest) (GitHubIntegration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GitHubIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.gitHubIntegrationCreate == nil {
		return localVarReturnValue, nil, reportError("gitHubIntegrationCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gitHubIntegrationCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsGithubDestroyRequest struct {
	ctx        _context.Context
	ApiService *IntegrationsApiService
	id         string
	inUse      *string
}

// (Optional) Desired behavior if the integration has in-use values.  - &#x60;fail&#x60; will return HTTP error 409 if there are any values using the integration. - &#x60;leave&#x60; (default) will leave values in place and future queries may fail; you can control future value query behavior with the &#x60;lookup_error&#x60; query parameter on those requests. - &#x60;remove&#x60; will remove the all values using the integration when the integration is removed.
func (r ApiIntegrationsGithubDestroyRequest) InUse(inUse string) ApiIntegrationsGithubDestroyRequest {
	r.inUse = &inUse
	return r
}

func (r ApiIntegrationsGithubDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IntegrationsGithubDestroyExecute(r)
}

/*
IntegrationsGithubDestroy Delete a GitHub integration.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsGithubDestroyRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubDestroy(ctx _context.Context, id string) ApiIntegrationsGithubDestroyRequest {
	return ApiIntegrationsGithubDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsGithubDestroyExecute(r ApiIntegrationsGithubDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.inUse != nil {
		localVarQueryParams.Add("in_use", parameterToString(*r.inUse, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsGithubListRequest struct {
	ctx                _context.Context
	ApiService         *IntegrationsApiService
	ghOrganizationSlug *string
	ordering           *string
	page               *int32
	pageSize           *int32
}

func (r ApiIntegrationsGithubListRequest) GhOrganizationSlug(ghOrganizationSlug string) ApiIntegrationsGithubListRequest {
	r.ghOrganizationSlug = &ghOrganizationSlug
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsGithubListRequest) Ordering(ordering string) ApiIntegrationsGithubListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsGithubListRequest) Page(page int32) ApiIntegrationsGithubListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsGithubListRequest) PageSize(pageSize int32) ApiIntegrationsGithubListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsGithubListRequest) Execute() (PaginatedGitHubIntegrationList, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsGithubListExecute(r)
}

/*
IntegrationsGithubList Method for IntegrationsGithubList

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntegrationsGithubListRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubList(ctx _context.Context) ApiIntegrationsGithubListRequest {
	return ApiIntegrationsGithubListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedGitHubIntegrationList
func (a *IntegrationsApiService) IntegrationsGithubListExecute(r ApiIntegrationsGithubListRequest) (PaginatedGitHubIntegrationList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedGitHubIntegrationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.ghOrganizationSlug != nil {
		localVarQueryParams.Add("gh_organization_slug", parameterToString(*r.ghOrganizationSlug, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsGithubRetrieveRequest struct {
	ctx           _context.Context
	ApiService    *IntegrationsApiService
	id            string
	refreshStatus *bool
}

// Refresh the integration status before returning the details.
func (r ApiIntegrationsGithubRetrieveRequest) RefreshStatus(refreshStatus bool) ApiIntegrationsGithubRetrieveRequest {
	r.refreshStatus = &refreshStatus
	return r
}

func (r ApiIntegrationsGithubRetrieveRequest) Execute() (GitHubIntegration, *_nethttp.Response, error) {
	return r.ApiService.IntegrationsGithubRetrieveExecute(r)
}

/*
IntegrationsGithubRetrieve Get details of a GitHub Integration.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsGithubRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubRetrieve(ctx _context.Context, id string) ApiIntegrationsGithubRetrieveRequest {
	return ApiIntegrationsGithubRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return GitHubIntegration
func (a *IntegrationsApiService) IntegrationsGithubRetrieveExecute(r ApiIntegrationsGithubRetrieveRequest) (GitHubIntegration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GitHubIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refreshStatus != nil {
		localVarQueryParams.Add("refresh_status", parameterToString(*r.refreshStatus, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
