/*
CloudTruth Management API

CloudTruth centralizes your configuration parameters and secrets making them easier to manage and use as a team.

API version: v1
Contact: support@cloudtruth.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cloudtruthapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// ProjectsApiService ProjectsApi service
type ProjectsApiService service

type ApiProjectsCreateRequest struct {
	ctx           context.Context
	ApiService    *ProjectsApiService
	projectCreate *ProjectCreate
}

func (r ApiProjectsCreateRequest) ProjectCreate(projectCreate ProjectCreate) ApiProjectsCreateRequest {
	r.projectCreate = &projectCreate
	return r
}

func (r ApiProjectsCreateRequest) Execute() (*Project, *http.Response, error) {
	return r.ApiService.ProjectsCreateExecute(r)
}

/*
ProjectsCreate Method for ProjectsCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiProjectsCreateRequest
*/
func (a *ProjectsApiService) ProjectsCreate(ctx context.Context) ApiProjectsCreateRequest {
	return ApiProjectsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Project
func (a *ProjectsApiService) ProjectsCreateExecute(r ApiProjectsCreateRequest) (*Project, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Project
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.projectCreate == nil {
		return localVarReturnValue, nil, reportError("projectCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.projectCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsDestroyRequest struct {
	ctx        context.Context
	ApiService *ProjectsApiService
	id         string
}

func (r ApiProjectsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectsDestroyExecute(r)
}

/*
ProjectsDestroy Method for ProjectsDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiProjectsDestroyRequest
*/
func (a *ProjectsApiService) ProjectsDestroy(ctx context.Context, id string) ApiProjectsDestroyRequest {
	return ApiProjectsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ProjectsApiService) ProjectsDestroyExecute(r ApiProjectsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectsListRequest struct {
	ctx                  context.Context
	ApiService           *ProjectsApiService
	descriptionIcontains *string
	name                 *string
	nameIcontains        *string
	ordering             *string
	page                 *int32
	pageSize             *int32
}

func (r ApiProjectsListRequest) DescriptionIcontains(descriptionIcontains string) ApiProjectsListRequest {
	r.descriptionIcontains = &descriptionIcontains
	return r
}

func (r ApiProjectsListRequest) Name(name string) ApiProjectsListRequest {
	r.name = &name
	return r
}

func (r ApiProjectsListRequest) NameIcontains(nameIcontains string) ApiProjectsListRequest {
	r.nameIcontains = &nameIcontains
	return r
}

// Which field to use when ordering the results.
func (r ApiProjectsListRequest) Ordering(ordering string) ApiProjectsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiProjectsListRequest) Page(page int32) ApiProjectsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiProjectsListRequest) PageSize(pageSize int32) ApiProjectsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiProjectsListRequest) Execute() (*PaginatedProjectList, *http.Response, error) {
	return r.ApiService.ProjectsListExecute(r)
}

/*
ProjectsList Method for ProjectsList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiProjectsListRequest
*/
func (a *ProjectsApiService) ProjectsList(ctx context.Context) ApiProjectsListRequest {
	return ApiProjectsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedProjectList
func (a *ProjectsApiService) ProjectsListExecute(r ApiProjectsListRequest) (*PaginatedProjectList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedProjectList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.descriptionIcontains != nil {
		localVarQueryParams.Add("description__icontains", parameterToString(*r.descriptionIcontains, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameIcontains != nil {
		localVarQueryParams.Add("name__icontains", parameterToString(*r.nameIcontains, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParameterExportListRequest struct {
	ctx            context.Context
	ApiService     *ProjectsApiService
	projectPk      string
	asOf           *time.Time
	contains       *string
	endswith       *string
	environment    *string
	explicitExport *bool
	maskSecrets    *bool
	ordering       *string
	output         *string
	startswith     *string
	tag            *string
	wrap           *bool
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;tag&#x60;.
func (r ApiProjectsParameterExportListRequest) AsOf(asOf time.Time) ApiProjectsParameterExportListRequest {
	r.asOf = &asOf
	return r
}

// Only include parameters with names that contain the provided string.
func (r ApiProjectsParameterExportListRequest) Contains(contains string) ApiProjectsParameterExportListRequest {
	r.contains = &contains
	return r
}

// Only include parameters with names that end with the provided string.
func (r ApiProjectsParameterExportListRequest) Endswith(endswith string) ApiProjectsParameterExportListRequest {
	r.endswith = &endswith
	return r
}

// Name or id of the environment to use to retrieve parameter values.
func (r ApiProjectsParameterExportListRequest) Environment(environment string) ApiProjectsParameterExportListRequest {
	r.environment = &environment
	return r
}

// Explicitly marks parameters with export, e.g. &#x60;export FOO&#x3D;bar&#x60;.
func (r ApiProjectsParameterExportListRequest) ExplicitExport(explicitExport bool) ApiProjectsParameterExportListRequest {
	r.explicitExport = &explicitExport
	return r
}

// Masks all secrets in the template with &#x60;*****&#x60;.
func (r ApiProjectsParameterExportListRequest) MaskSecrets(maskSecrets bool) ApiProjectsParameterExportListRequest {
	r.maskSecrets = &maskSecrets
	return r
}

// Which field to use when ordering the results.
func (r ApiProjectsParameterExportListRequest) Ordering(ordering string) ApiProjectsParameterExportListRequest {
	r.ordering = &ordering
	return r
}

// Format to output: One of &#39;docker&#39;, &#39;dotenv&#39;, &#39;shell&#39;.
func (r ApiProjectsParameterExportListRequest) Output(output string) ApiProjectsParameterExportListRequest {
	r.output = &output
	return r
}

// Only include parameters with names that start with the provided string.
func (r ApiProjectsParameterExportListRequest) Startswith(startswith string) ApiProjectsParameterExportListRequest {
	r.startswith = &startswith
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsParameterExportListRequest) Tag(tag string) ApiProjectsParameterExportListRequest {
	r.tag = &tag
	return r
}

// Indicates all secrets are wrapped. For more information on secret wrapping, see the documentation.
func (r ApiProjectsParameterExportListRequest) Wrap(wrap bool) ApiProjectsParameterExportListRequest {
	r.wrap = &wrap
	return r
}

func (r ApiProjectsParameterExportListRequest) Execute() (*ParameterExport, *http.Response, error) {
	return r.ApiService.ProjectsParameterExportListExecute(r)
}

/*
ProjectsParameterExportList Method for ProjectsParameterExportList

Exports all parameters in this project in the requested format.

Parameter names and values will be coerced to the proper format (e.g. for a
dotenv export, my_parameter will be capitalized to MY_PARAMETER and its value
will be in a quoted string).  Note that capitalization is the only name coercion
that will be performed on parameter names, names that are invalid for a given
format will be omitted.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectPk
	@return ApiProjectsParameterExportListRequest
*/
func (a *ProjectsApiService) ProjectsParameterExportList(ctx context.Context, projectPk string) ApiProjectsParameterExportListRequest {
	return ApiProjectsParameterExportListRequest{
		ApiService: a,
		ctx:        ctx,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return ParameterExport
func (a *ProjectsApiService) ProjectsParameterExportListExecute(r ApiProjectsParameterExportListRequest) (*ParameterExport, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ParameterExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParameterExportList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameter-export/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asOf != nil {
		localVarQueryParams.Add("as_of", parameterToString(*r.asOf, ""))
	}
	if r.contains != nil {
		localVarQueryParams.Add("contains", parameterToString(*r.contains, ""))
	}
	if r.endswith != nil {
		localVarQueryParams.Add("endswith", parameterToString(*r.endswith, ""))
	}
	if r.environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.environment, ""))
	}
	if r.explicitExport != nil {
		localVarQueryParams.Add("explicit_export", parameterToString(*r.explicitExport, ""))
	}
	if r.maskSecrets != nil {
		localVarQueryParams.Add("mask_secrets", parameterToString(*r.maskSecrets, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.output != nil {
		localVarQueryParams.Add("output", parameterToString(*r.output, ""))
	}
	if r.startswith != nil {
		localVarQueryParams.Add("startswith", parameterToString(*r.startswith, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.wrap != nil {
		localVarQueryParams.Add("wrap", parameterToString(*r.wrap, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v TemplateLookupError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersCreateRequest struct {
	ctx             context.Context
	ApiService      *ProjectsApiService
	projectPk       string
	parameterCreate *ParameterCreate
}

func (r ApiProjectsParametersCreateRequest) ParameterCreate(parameterCreate ParameterCreate) ApiProjectsParametersCreateRequest {
	r.parameterCreate = &parameterCreate
	return r
}

func (r ApiProjectsParametersCreateRequest) Execute() (*Parameter, *http.Response, error) {
	return r.ApiService.ProjectsParametersCreateExecute(r)
}

/*
ProjectsParametersCreate Method for ProjectsParametersCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectPk
	@return ApiProjectsParametersCreateRequest
*/
func (a *ProjectsApiService) ProjectsParametersCreate(ctx context.Context, projectPk string) ApiProjectsParametersCreateRequest {
	return ApiProjectsParametersCreateRequest{
		ApiService: a,
		ctx:        ctx,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return Parameter
func (a *ProjectsApiService) ProjectsParametersCreateExecute(r ApiProjectsParametersCreateRequest) (*Parameter, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Parameter
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.parameterCreate == nil {
		return localVarReturnValue, nil, reportError("parameterCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.parameterCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersDestroyRequest struct {
	ctx        context.Context
	ApiService *ProjectsApiService
	id         string
	projectPk  string
}

func (r ApiProjectsParametersDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectsParametersDestroyExecute(r)
}

/*
ProjectsParametersDestroy Method for ProjectsParametersDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param projectPk
	@return ApiProjectsParametersDestroyRequest
*/
func (a *ProjectsApiService) ProjectsParametersDestroy(ctx context.Context, id string, projectPk string) ApiProjectsParametersDestroyRequest {
	return ApiProjectsParametersDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		projectPk:  projectPk,
	}
}

// Execute executes the request
func (a *ProjectsApiService) ProjectsParametersDestroyExecute(r ApiProjectsParametersDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectsParametersDualityListRequest struct {
	ctx             context.Context
	ApiService      *ProjectsApiService
	projectPk       string
	difference      *bool
	environment     *string
	evaluate        *bool
	maskSecrets     *bool
	name            *string
	nameContains    *string
	nameIcontains   *string
	nameIexact      *string
	nameIstartswith *string
	nameStartswith  *string
	ordering        *string
	page            *int32
	pageSize        *int32
	secret          *bool
	t1AsOf          *time.Time
	t1Tag           *string
	t2AsOf          *time.Time
	t2Tag           *string
	values          *bool
	wrap            *bool
}

// Compare the values at &#x60;t1&#x60; and &#x60;t2&#x60; and if they are the same, omit the parameter from the result.
func (r ApiProjectsParametersDualityListRequest) Difference(difference bool) ApiProjectsParametersDualityListRequest {
	r.difference = &difference
	return r
}

// Name or id (uuid) of the environment to get parameter values for. Cannot be used with &#x60;values&#x60;.
func (r ApiProjectsParametersDualityListRequest) Environment(environment string) ApiProjectsParametersDualityListRequest {
	r.environment = &environment
	return r
}

// If &#x60;true&#x60;, runs template evaluation on this parameter&#39;s values.  If &#x60;false&#x60;, returns the value&#39;s template. Has no effect on values that are not interpolated.
func (r ApiProjectsParametersDualityListRequest) Evaluate(evaluate bool) ApiProjectsParametersDualityListRequest {
	r.evaluate = &evaluate
	return r
}

// If true, replaces all secrets with &#x60;*****&#x60;.
func (r ApiProjectsParametersDualityListRequest) MaskSecrets(maskSecrets bool) ApiProjectsParametersDualityListRequest {
	r.maskSecrets = &maskSecrets
	return r
}

func (r ApiProjectsParametersDualityListRequest) Name(name string) ApiProjectsParametersDualityListRequest {
	r.name = &name
	return r
}

func (r ApiProjectsParametersDualityListRequest) NameContains(nameContains string) ApiProjectsParametersDualityListRequest {
	r.nameContains = &nameContains
	return r
}

func (r ApiProjectsParametersDualityListRequest) NameIcontains(nameIcontains string) ApiProjectsParametersDualityListRequest {
	r.nameIcontains = &nameIcontains
	return r
}

func (r ApiProjectsParametersDualityListRequest) NameIexact(nameIexact string) ApiProjectsParametersDualityListRequest {
	r.nameIexact = &nameIexact
	return r
}

func (r ApiProjectsParametersDualityListRequest) NameIstartswith(nameIstartswith string) ApiProjectsParametersDualityListRequest {
	r.nameIstartswith = &nameIstartswith
	return r
}

func (r ApiProjectsParametersDualityListRequest) NameStartswith(nameStartswith string) ApiProjectsParametersDualityListRequest {
	r.nameStartswith = &nameStartswith
	return r
}

// Which field to use when ordering the results.
func (r ApiProjectsParametersDualityListRequest) Ordering(ordering string) ApiProjectsParametersDualityListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiProjectsParametersDualityListRequest) Page(page int32) ApiProjectsParametersDualityListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiProjectsParametersDualityListRequest) PageSize(pageSize int32) ApiProjectsParametersDualityListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiProjectsParametersDualityListRequest) Secret(secret bool) ApiProjectsParametersDualityListRequest {
	r.secret = &secret
	return r
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;t1_tag&#x60;.
func (r ApiProjectsParametersDualityListRequest) T1AsOf(t1AsOf time.Time) ApiProjectsParametersDualityListRequest {
	r.t1AsOf = &t1AsOf
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;t1_as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsParametersDualityListRequest) T1Tag(t1Tag string) ApiProjectsParametersDualityListRequest {
	r.t1Tag = &t1Tag
	return r
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;t2_tag&#x60;.
func (r ApiProjectsParametersDualityListRequest) T2AsOf(t2AsOf time.Time) ApiProjectsParametersDualityListRequest {
	r.t2AsOf = &t2AsOf
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;t2_as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsParametersDualityListRequest) T2Tag(t2Tag string) ApiProjectsParametersDualityListRequest {
	r.t2Tag = &t2Tag
	return r
}

// If false, values are not returned: the &#x60;values&#x60; array will have no entries. This speeds up retrieval if value content is not needed. Cannot be used with &#x60;environment&#x60;.
func (r ApiProjectsParametersDualityListRequest) Values(values bool) ApiProjectsParametersDualityListRequest {
	r.values = &values
	return r
}

// Wrap secrets.
func (r ApiProjectsParametersDualityListRequest) Wrap(wrap bool) ApiProjectsParametersDualityListRequest {
	r.wrap = &wrap
	return r
}

func (r ApiProjectsParametersDualityListRequest) Execute() (*PaginatedParameterDualityList, *http.Response, error) {
	return r.ApiService.ProjectsParametersDualityListExecute(r)
}

/*
ProjectsParametersDualityList Method for ProjectsParametersDualityList

Retrieve parameters at dual timepoints for comparison.

Results are aligned by parameter name.  This means if a parameter is
created, then deleted, then created again with the same name the two
records with different parameter IDs will show up in the same result
entry.

If t1 is not specified then it will point to a time in the past where
nothing existed.  If t2 is not specified then it is assumed to be "now".

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectPk
	@return ApiProjectsParametersDualityListRequest
*/
func (a *ProjectsApiService) ProjectsParametersDualityList(ctx context.Context, projectPk string) ApiProjectsParametersDualityListRequest {
	return ApiProjectsParametersDualityListRequest{
		ApiService: a,
		ctx:        ctx,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return PaginatedParameterDualityList
func (a *ProjectsApiService) ProjectsParametersDualityListExecute(r ApiProjectsParametersDualityListRequest) (*PaginatedParameterDualityList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedParameterDualityList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersDualityList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/duality/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.difference != nil {
		localVarQueryParams.Add("difference", parameterToString(*r.difference, ""))
	}
	if r.environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.environment, ""))
	}
	if r.evaluate != nil {
		localVarQueryParams.Add("evaluate", parameterToString(*r.evaluate, ""))
	}
	if r.maskSecrets != nil {
		localVarQueryParams.Add("mask_secrets", parameterToString(*r.maskSecrets, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameContains != nil {
		localVarQueryParams.Add("name__contains", parameterToString(*r.nameContains, ""))
	}
	if r.nameIcontains != nil {
		localVarQueryParams.Add("name__icontains", parameterToString(*r.nameIcontains, ""))
	}
	if r.nameIexact != nil {
		localVarQueryParams.Add("name__iexact", parameterToString(*r.nameIexact, ""))
	}
	if r.nameIstartswith != nil {
		localVarQueryParams.Add("name__istartswith", parameterToString(*r.nameIstartswith, ""))
	}
	if r.nameStartswith != nil {
		localVarQueryParams.Add("name__startswith", parameterToString(*r.nameStartswith, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.secret != nil {
		localVarQueryParams.Add("secret", parameterToString(*r.secret, ""))
	}
	if r.t1AsOf != nil {
		localVarQueryParams.Add("t1_as_of", parameterToString(*r.t1AsOf, ""))
	}
	if r.t1Tag != nil {
		localVarQueryParams.Add("t1_tag", parameterToString(*r.t1Tag, ""))
	}
	if r.t2AsOf != nil {
		localVarQueryParams.Add("t2_as_of", parameterToString(*r.t2AsOf, ""))
	}
	if r.t2Tag != nil {
		localVarQueryParams.Add("t2_tag", parameterToString(*r.t2Tag, ""))
	}
	if r.values != nil {
		localVarQueryParams.Add("values", parameterToString(*r.values, ""))
	}
	if r.wrap != nil {
		localVarQueryParams.Add("wrap", parameterToString(*r.wrap, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersListRequest struct {
	ctx                    context.Context
	ApiService             *ProjectsApiService
	projectPk              string
	asOf                   *time.Time
	descriptionIcontains   *string
	difference             *string
	environment            *string
	evaluate               *bool
	idIn                   *[]string
	maskSecrets            *bool
	name                   *string
	nameContains           *string
	nameIcontains          *string
	nameIexact             *string
	nameIstartswith        *string
	nameStartswith         *string
	ordering               *string
	page                   *int32
	pageSize               *int32
	projectName            *string
	projectNameContains    *string
	projectNameIcontains   *string
	projectNameIexact      *string
	projectNameIstartswith *string
	projectNameStartswith  *string
	secret                 *bool
	tag                    *string
	values                 *bool
	wrap                   *bool
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;tag&#x60;.
func (r ApiProjectsParametersListRequest) AsOf(asOf time.Time) ApiProjectsParametersListRequest {
	r.asOf = &asOf
	return r
}

func (r ApiProjectsParametersListRequest) DescriptionIcontains(descriptionIcontains string) ApiProjectsParametersListRequest {
	r.descriptionIcontains = &descriptionIcontains
	return r
}

// Specify a list of comma-separated environment names or ids (uuid) to compare values. Only returns a parameter if there is a difference. Cannot be used with &#x60;environment&#x60;, &#x60;wrap&#x60; or &#x60;values&#x60;. If used with &#x60;mask_secrets&#x60; then no secret parameters will be included in the result.
func (r ApiProjectsParametersListRequest) Difference(difference string) ApiProjectsParametersListRequest {
	r.difference = &difference
	return r
}

// Name or id (uuid) of the environment to get parameter values for. Cannot be used with &#x60;values&#x60;.
func (r ApiProjectsParametersListRequest) Environment(environment string) ApiProjectsParametersListRequest {
	r.environment = &environment
	return r
}

// If &#x60;true&#x60;, runs template evaluation on this parameter&#39;s values.  If &#x60;false&#x60;, returns the value&#39;s template. Has no effect on values that are not interpolated.
func (r ApiProjectsParametersListRequest) Evaluate(evaluate bool) ApiProjectsParametersListRequest {
	r.evaluate = &evaluate
	return r
}

// Multiple values may be separated by commas.
func (r ApiProjectsParametersListRequest) IdIn(idIn []string) ApiProjectsParametersListRequest {
	r.idIn = &idIn
	return r
}

// If true, replaces all secrets with &#x60;*****&#x60;.
func (r ApiProjectsParametersListRequest) MaskSecrets(maskSecrets bool) ApiProjectsParametersListRequest {
	r.maskSecrets = &maskSecrets
	return r
}

func (r ApiProjectsParametersListRequest) Name(name string) ApiProjectsParametersListRequest {
	r.name = &name
	return r
}

func (r ApiProjectsParametersListRequest) NameContains(nameContains string) ApiProjectsParametersListRequest {
	r.nameContains = &nameContains
	return r
}

func (r ApiProjectsParametersListRequest) NameIcontains(nameIcontains string) ApiProjectsParametersListRequest {
	r.nameIcontains = &nameIcontains
	return r
}

func (r ApiProjectsParametersListRequest) NameIexact(nameIexact string) ApiProjectsParametersListRequest {
	r.nameIexact = &nameIexact
	return r
}

func (r ApiProjectsParametersListRequest) NameIstartswith(nameIstartswith string) ApiProjectsParametersListRequest {
	r.nameIstartswith = &nameIstartswith
	return r
}

func (r ApiProjectsParametersListRequest) NameStartswith(nameStartswith string) ApiProjectsParametersListRequest {
	r.nameStartswith = &nameStartswith
	return r
}

// Which field to use when ordering the results.
func (r ApiProjectsParametersListRequest) Ordering(ordering string) ApiProjectsParametersListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiProjectsParametersListRequest) Page(page int32) ApiProjectsParametersListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiProjectsParametersListRequest) PageSize(pageSize int32) ApiProjectsParametersListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiProjectsParametersListRequest) ProjectName(projectName string) ApiProjectsParametersListRequest {
	r.projectName = &projectName
	return r
}

func (r ApiProjectsParametersListRequest) ProjectNameContains(projectNameContains string) ApiProjectsParametersListRequest {
	r.projectNameContains = &projectNameContains
	return r
}

func (r ApiProjectsParametersListRequest) ProjectNameIcontains(projectNameIcontains string) ApiProjectsParametersListRequest {
	r.projectNameIcontains = &projectNameIcontains
	return r
}

func (r ApiProjectsParametersListRequest) ProjectNameIexact(projectNameIexact string) ApiProjectsParametersListRequest {
	r.projectNameIexact = &projectNameIexact
	return r
}

func (r ApiProjectsParametersListRequest) ProjectNameIstartswith(projectNameIstartswith string) ApiProjectsParametersListRequest {
	r.projectNameIstartswith = &projectNameIstartswith
	return r
}

func (r ApiProjectsParametersListRequest) ProjectNameStartswith(projectNameStartswith string) ApiProjectsParametersListRequest {
	r.projectNameStartswith = &projectNameStartswith
	return r
}

func (r ApiProjectsParametersListRequest) Secret(secret bool) ApiProjectsParametersListRequest {
	r.secret = &secret
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsParametersListRequest) Tag(tag string) ApiProjectsParametersListRequest {
	r.tag = &tag
	return r
}

// If false, values are not returned: the &#x60;values&#x60; array will have no entries. This speeds up retrieval if value content is not needed. Cannot be used with &#x60;environment&#x60;.
func (r ApiProjectsParametersListRequest) Values(values bool) ApiProjectsParametersListRequest {
	r.values = &values
	return r
}

// Wrap secrets.
func (r ApiProjectsParametersListRequest) Wrap(wrap bool) ApiProjectsParametersListRequest {
	r.wrap = &wrap
	return r
}

func (r ApiProjectsParametersListRequest) Execute() (*PaginatedParameterList, *http.Response, error) {
	return r.ApiService.ProjectsParametersListExecute(r)
}

/*
ProjectsParametersList Method for ProjectsParametersList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectPk
	@return ApiProjectsParametersListRequest
*/
func (a *ProjectsApiService) ProjectsParametersList(ctx context.Context, projectPk string) ApiProjectsParametersListRequest {
	return ApiProjectsParametersListRequest{
		ApiService: a,
		ctx:        ctx,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return PaginatedParameterList
func (a *ProjectsApiService) ProjectsParametersListExecute(r ApiProjectsParametersListRequest) (*PaginatedParameterList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedParameterList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asOf != nil {
		localVarQueryParams.Add("as_of", parameterToString(*r.asOf, ""))
	}
	if r.descriptionIcontains != nil {
		localVarQueryParams.Add("description__icontains", parameterToString(*r.descriptionIcontains, ""))
	}
	if r.difference != nil {
		localVarQueryParams.Add("difference", parameterToString(*r.difference, ""))
	}
	if r.environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.environment, ""))
	}
	if r.evaluate != nil {
		localVarQueryParams.Add("evaluate", parameterToString(*r.evaluate, ""))
	}
	if r.idIn != nil {
		localVarQueryParams.Add("id__in", parameterToString(*r.idIn, "csv"))
	}
	if r.maskSecrets != nil {
		localVarQueryParams.Add("mask_secrets", parameterToString(*r.maskSecrets, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameContains != nil {
		localVarQueryParams.Add("name__contains", parameterToString(*r.nameContains, ""))
	}
	if r.nameIcontains != nil {
		localVarQueryParams.Add("name__icontains", parameterToString(*r.nameIcontains, ""))
	}
	if r.nameIexact != nil {
		localVarQueryParams.Add("name__iexact", parameterToString(*r.nameIexact, ""))
	}
	if r.nameIstartswith != nil {
		localVarQueryParams.Add("name__istartswith", parameterToString(*r.nameIstartswith, ""))
	}
	if r.nameStartswith != nil {
		localVarQueryParams.Add("name__startswith", parameterToString(*r.nameStartswith, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.projectName != nil {
		localVarQueryParams.Add("project__name", parameterToString(*r.projectName, ""))
	}
	if r.projectNameContains != nil {
		localVarQueryParams.Add("project__name__contains", parameterToString(*r.projectNameContains, ""))
	}
	if r.projectNameIcontains != nil {
		localVarQueryParams.Add("project__name__icontains", parameterToString(*r.projectNameIcontains, ""))
	}
	if r.projectNameIexact != nil {
		localVarQueryParams.Add("project__name__iexact", parameterToString(*r.projectNameIexact, ""))
	}
	if r.projectNameIstartswith != nil {
		localVarQueryParams.Add("project__name__istartswith", parameterToString(*r.projectNameIstartswith, ""))
	}
	if r.projectNameStartswith != nil {
		localVarQueryParams.Add("project__name__startswith", parameterToString(*r.projectNameStartswith, ""))
	}
	if r.secret != nil {
		localVarQueryParams.Add("secret", parameterToString(*r.secret, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.values != nil {
		localVarQueryParams.Add("values", parameterToString(*r.values, ""))
	}
	if r.wrap != nil {
		localVarQueryParams.Add("wrap", parameterToString(*r.wrap, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersPartialUpdateRequest struct {
	ctx              context.Context
	ApiService       *ProjectsApiService
	id               string
	projectPk        string
	patchedParameter *PatchedParameter
}

func (r ApiProjectsParametersPartialUpdateRequest) PatchedParameter(patchedParameter PatchedParameter) ApiProjectsParametersPartialUpdateRequest {
	r.patchedParameter = &patchedParameter
	return r
}

func (r ApiProjectsParametersPartialUpdateRequest) Execute() (*Parameter, *http.Response, error) {
	return r.ApiService.ProjectsParametersPartialUpdateExecute(r)
}

/*
ProjectsParametersPartialUpdate Method for ProjectsParametersPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param projectPk
	@return ApiProjectsParametersPartialUpdateRequest
*/
func (a *ProjectsApiService) ProjectsParametersPartialUpdate(ctx context.Context, id string, projectPk string) ApiProjectsParametersPartialUpdateRequest {
	return ApiProjectsParametersPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return Parameter
func (a *ProjectsApiService) ProjectsParametersPartialUpdateExecute(r ApiProjectsParametersPartialUpdateRequest) (*Parameter, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Parameter
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedParameter
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersPushesListRequest struct {
	ctx         context.Context
	ApiService  *ProjectsApiService
	parameterPk string
	projectPk   string
	asOf        *time.Time
	ordering    *string
	page        *int32
	pageSize    *int32
	tag         *string
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;tag&#x60;.
func (r ApiProjectsParametersPushesListRequest) AsOf(asOf time.Time) ApiProjectsParametersPushesListRequest {
	r.asOf = &asOf
	return r
}

// Which field to use when ordering the results.
func (r ApiProjectsParametersPushesListRequest) Ordering(ordering string) ApiProjectsParametersPushesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiProjectsParametersPushesListRequest) Page(page int32) ApiProjectsParametersPushesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiProjectsParametersPushesListRequest) PageSize(pageSize int32) ApiProjectsParametersPushesListRequest {
	r.pageSize = &pageSize
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsParametersPushesListRequest) Tag(tag string) ApiProjectsParametersPushesListRequest {
	r.tag = &tag
	return r
}

func (r ApiProjectsParametersPushesListRequest) Execute() (*PaginatedTaskStepList, *http.Response, error) {
	return r.ApiService.ProjectsParametersPushesListExecute(r)
}

/*
ProjectsParametersPushesList List push operations.

The push operations that this parameter was involved in.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param parameterPk
	@param projectPk
	@return ApiProjectsParametersPushesListRequest
*/
func (a *ProjectsApiService) ProjectsParametersPushesList(ctx context.Context, parameterPk string, projectPk string) ApiProjectsParametersPushesListRequest {
	return ApiProjectsParametersPushesListRequest{
		ApiService:  a,
		ctx:         ctx,
		parameterPk: parameterPk,
		projectPk:   projectPk,
	}
}

// Execute executes the request
//
//	@return PaginatedTaskStepList
func (a *ProjectsApiService) ProjectsParametersPushesListExecute(r ApiProjectsParametersPushesListRequest) (*PaginatedTaskStepList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedTaskStepList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersPushesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{parameter_pk}/pushes/"
	localVarPath = strings.Replace(localVarPath, "{"+"parameter_pk"+"}", url.PathEscape(parameterToString(r.parameterPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asOf != nil {
		localVarQueryParams.Add("as_of", parameterToString(*r.asOf, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersRetrieveRequest struct {
	ctx         context.Context
	ApiService  *ProjectsApiService
	id          string
	projectPk   string
	asOf        *time.Time
	environment *string
	evaluate    *bool
	maskSecrets *bool
	tag         *string
	values      *bool
	wrap        *bool
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;tag&#x60;.
func (r ApiProjectsParametersRetrieveRequest) AsOf(asOf time.Time) ApiProjectsParametersRetrieveRequest {
	r.asOf = &asOf
	return r
}

// Name or id (uuid) of the environment to get parameter values for. Cannot be used with &#x60;values&#x60;.
func (r ApiProjectsParametersRetrieveRequest) Environment(environment string) ApiProjectsParametersRetrieveRequest {
	r.environment = &environment
	return r
}

// If &#x60;true&#x60;, runs template evaluation on this parameter&#39;s values.  If &#x60;false&#x60;, returns the value&#39;s template. Has no effect on values that are not interpolated.
func (r ApiProjectsParametersRetrieveRequest) Evaluate(evaluate bool) ApiProjectsParametersRetrieveRequest {
	r.evaluate = &evaluate
	return r
}

// If true, replaces all secrets with &#x60;*****&#x60;.
func (r ApiProjectsParametersRetrieveRequest) MaskSecrets(maskSecrets bool) ApiProjectsParametersRetrieveRequest {
	r.maskSecrets = &maskSecrets
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsParametersRetrieveRequest) Tag(tag string) ApiProjectsParametersRetrieveRequest {
	r.tag = &tag
	return r
}

// If false, values are not returned: the &#x60;values&#x60; array will have no entries. This speeds up retrieval if value content is not needed. Cannot be used with &#x60;environment&#x60;.
func (r ApiProjectsParametersRetrieveRequest) Values(values bool) ApiProjectsParametersRetrieveRequest {
	r.values = &values
	return r
}

// Wrap secrets.
func (r ApiProjectsParametersRetrieveRequest) Wrap(wrap bool) ApiProjectsParametersRetrieveRequest {
	r.wrap = &wrap
	return r
}

func (r ApiProjectsParametersRetrieveRequest) Execute() (*Parameter, *http.Response, error) {
	return r.ApiService.ProjectsParametersRetrieveExecute(r)
}

/*
ProjectsParametersRetrieve Method for ProjectsParametersRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param projectPk
	@return ApiProjectsParametersRetrieveRequest
*/
func (a *ProjectsApiService) ProjectsParametersRetrieve(ctx context.Context, id string, projectPk string) ApiProjectsParametersRetrieveRequest {
	return ApiProjectsParametersRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return Parameter
func (a *ProjectsApiService) ProjectsParametersRetrieveExecute(r ApiProjectsParametersRetrieveRequest) (*Parameter, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Parameter
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asOf != nil {
		localVarQueryParams.Add("as_of", parameterToString(*r.asOf, ""))
	}
	if r.environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.environment, ""))
	}
	if r.evaluate != nil {
		localVarQueryParams.Add("evaluate", parameterToString(*r.evaluate, ""))
	}
	if r.maskSecrets != nil {
		localVarQueryParams.Add("mask_secrets", parameterToString(*r.maskSecrets, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.values != nil {
		localVarQueryParams.Add("values", parameterToString(*r.values, ""))
	}
	if r.wrap != nil {
		localVarQueryParams.Add("wrap", parameterToString(*r.wrap, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersRulesCreateRequest struct {
	ctx                 context.Context
	ApiService          *ProjectsApiService
	parameterPk         string
	projectPk           string
	parameterRuleCreate *ParameterRuleCreate
}

func (r ApiProjectsParametersRulesCreateRequest) ParameterRuleCreate(parameterRuleCreate ParameterRuleCreate) ApiProjectsParametersRulesCreateRequest {
	r.parameterRuleCreate = &parameterRuleCreate
	return r
}

func (r ApiProjectsParametersRulesCreateRequest) Execute() (*ParameterRule, *http.Response, error) {
	return r.ApiService.ProjectsParametersRulesCreateExecute(r)
}

/*
ProjectsParametersRulesCreate Method for ProjectsParametersRulesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param parameterPk The parameter id.
	@param projectPk The project id.
	@return ApiProjectsParametersRulesCreateRequest
*/
func (a *ProjectsApiService) ProjectsParametersRulesCreate(ctx context.Context, parameterPk string, projectPk string) ApiProjectsParametersRulesCreateRequest {
	return ApiProjectsParametersRulesCreateRequest{
		ApiService:  a,
		ctx:         ctx,
		parameterPk: parameterPk,
		projectPk:   projectPk,
	}
}

// Execute executes the request
//
//	@return ParameterRule
func (a *ProjectsApiService) ProjectsParametersRulesCreateExecute(r ApiProjectsParametersRulesCreateRequest) (*ParameterRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ParameterRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersRulesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{parameter_pk}/rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"parameter_pk"+"}", url.PathEscape(parameterToString(r.parameterPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.parameterRuleCreate == nil {
		return localVarReturnValue, nil, reportError("parameterRuleCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.parameterRuleCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersRulesDestroyRequest struct {
	ctx         context.Context
	ApiService  *ProjectsApiService
	id          string
	parameterPk string
	projectPk   string
}

func (r ApiProjectsParametersRulesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectsParametersRulesDestroyExecute(r)
}

/*
ProjectsParametersRulesDestroy Method for ProjectsParametersRulesDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this parameter rule.
	@param parameterPk The parameter id.
	@param projectPk The project id.
	@return ApiProjectsParametersRulesDestroyRequest
*/
func (a *ProjectsApiService) ProjectsParametersRulesDestroy(ctx context.Context, id string, parameterPk string, projectPk string) ApiProjectsParametersRulesDestroyRequest {
	return ApiProjectsParametersRulesDestroyRequest{
		ApiService:  a,
		ctx:         ctx,
		id:          id,
		parameterPk: parameterPk,
		projectPk:   projectPk,
	}
}

// Execute executes the request
func (a *ProjectsApiService) ProjectsParametersRulesDestroyExecute(r ApiProjectsParametersRulesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersRulesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{parameter_pk}/rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parameter_pk"+"}", url.PathEscape(parameterToString(r.parameterPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectsParametersRulesListRequest struct {
	ctx         context.Context
	ApiService  *ProjectsApiService
	parameterPk string
	projectPk   string
	ordering    *string
	page        *int32
	pageSize    *int32
	type_       *string
}

// Which field to use when ordering the results.
func (r ApiProjectsParametersRulesListRequest) Ordering(ordering string) ApiProjectsParametersRulesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiProjectsParametersRulesListRequest) Page(page int32) ApiProjectsParametersRulesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiProjectsParametersRulesListRequest) PageSize(pageSize int32) ApiProjectsParametersRulesListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiProjectsParametersRulesListRequest) Type_(type_ string) ApiProjectsParametersRulesListRequest {
	r.type_ = &type_
	return r
}

func (r ApiProjectsParametersRulesListRequest) Execute() (*PaginatedParameterRuleList, *http.Response, error) {
	return r.ApiService.ProjectsParametersRulesListExecute(r)
}

/*
ProjectsParametersRulesList Method for ProjectsParametersRulesList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param parameterPk The parameter id.
	@param projectPk The project id.
	@return ApiProjectsParametersRulesListRequest
*/
func (a *ProjectsApiService) ProjectsParametersRulesList(ctx context.Context, parameterPk string, projectPk string) ApiProjectsParametersRulesListRequest {
	return ApiProjectsParametersRulesListRequest{
		ApiService:  a,
		ctx:         ctx,
		parameterPk: parameterPk,
		projectPk:   projectPk,
	}
}

// Execute executes the request
//
//	@return PaginatedParameterRuleList
func (a *ProjectsApiService) ProjectsParametersRulesListExecute(r ApiProjectsParametersRulesListRequest) (*PaginatedParameterRuleList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedParameterRuleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersRulesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{parameter_pk}/rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"parameter_pk"+"}", url.PathEscape(parameterToString(r.parameterPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersRulesPartialUpdateRequest struct {
	ctx                  context.Context
	ApiService           *ProjectsApiService
	id                   string
	parameterPk          string
	projectPk            string
	patchedParameterRule *PatchedParameterRule
}

func (r ApiProjectsParametersRulesPartialUpdateRequest) PatchedParameterRule(patchedParameterRule PatchedParameterRule) ApiProjectsParametersRulesPartialUpdateRequest {
	r.patchedParameterRule = &patchedParameterRule
	return r
}

func (r ApiProjectsParametersRulesPartialUpdateRequest) Execute() (*ParameterRule, *http.Response, error) {
	return r.ApiService.ProjectsParametersRulesPartialUpdateExecute(r)
}

/*
ProjectsParametersRulesPartialUpdate Method for ProjectsParametersRulesPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this parameter rule.
	@param parameterPk The parameter id.
	@param projectPk The project id.
	@return ApiProjectsParametersRulesPartialUpdateRequest
*/
func (a *ProjectsApiService) ProjectsParametersRulesPartialUpdate(ctx context.Context, id string, parameterPk string, projectPk string) ApiProjectsParametersRulesPartialUpdateRequest {
	return ApiProjectsParametersRulesPartialUpdateRequest{
		ApiService:  a,
		ctx:         ctx,
		id:          id,
		parameterPk: parameterPk,
		projectPk:   projectPk,
	}
}

// Execute executes the request
//
//	@return ParameterRule
func (a *ProjectsApiService) ProjectsParametersRulesPartialUpdateExecute(r ApiProjectsParametersRulesPartialUpdateRequest) (*ParameterRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ParameterRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersRulesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{parameter_pk}/rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parameter_pk"+"}", url.PathEscape(parameterToString(r.parameterPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedParameterRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersRulesRetrieveRequest struct {
	ctx         context.Context
	ApiService  *ProjectsApiService
	id          string
	parameterPk string
	projectPk   string
}

func (r ApiProjectsParametersRulesRetrieveRequest) Execute() (*ParameterRule, *http.Response, error) {
	return r.ApiService.ProjectsParametersRulesRetrieveExecute(r)
}

/*
ProjectsParametersRulesRetrieve Method for ProjectsParametersRulesRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this parameter rule.
	@param parameterPk The parameter id.
	@param projectPk The project id.
	@return ApiProjectsParametersRulesRetrieveRequest
*/
func (a *ProjectsApiService) ProjectsParametersRulesRetrieve(ctx context.Context, id string, parameterPk string, projectPk string) ApiProjectsParametersRulesRetrieveRequest {
	return ApiProjectsParametersRulesRetrieveRequest{
		ApiService:  a,
		ctx:         ctx,
		id:          id,
		parameterPk: parameterPk,
		projectPk:   projectPk,
	}
}

// Execute executes the request
//
//	@return ParameterRule
func (a *ProjectsApiService) ProjectsParametersRulesRetrieveExecute(r ApiProjectsParametersRulesRetrieveRequest) (*ParameterRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ParameterRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersRulesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{parameter_pk}/rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parameter_pk"+"}", url.PathEscape(parameterToString(r.parameterPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersRulesUpdateRequest struct {
	ctx           context.Context
	ApiService    *ProjectsApiService
	id            string
	parameterPk   string
	projectPk     string
	parameterRule *ParameterRule
}

func (r ApiProjectsParametersRulesUpdateRequest) ParameterRule(parameterRule ParameterRule) ApiProjectsParametersRulesUpdateRequest {
	r.parameterRule = &parameterRule
	return r
}

func (r ApiProjectsParametersRulesUpdateRequest) Execute() (*ParameterRule, *http.Response, error) {
	return r.ApiService.ProjectsParametersRulesUpdateExecute(r)
}

/*
ProjectsParametersRulesUpdate Method for ProjectsParametersRulesUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A UUID string identifying this parameter rule.
	@param parameterPk The parameter id.
	@param projectPk The project id.
	@return ApiProjectsParametersRulesUpdateRequest
*/
func (a *ProjectsApiService) ProjectsParametersRulesUpdate(ctx context.Context, id string, parameterPk string, projectPk string) ApiProjectsParametersRulesUpdateRequest {
	return ApiProjectsParametersRulesUpdateRequest{
		ApiService:  a,
		ctx:         ctx,
		id:          id,
		parameterPk: parameterPk,
		projectPk:   projectPk,
	}
}

// Execute executes the request
//
//	@return ParameterRule
func (a *ProjectsApiService) ProjectsParametersRulesUpdateExecute(r ApiProjectsParametersRulesUpdateRequest) (*ParameterRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ParameterRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersRulesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{parameter_pk}/rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parameter_pk"+"}", url.PathEscape(parameterToString(r.parameterPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.parameterRule == nil {
		return localVarReturnValue, nil, reportError("parameterRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.parameterRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersTimelineRetrieveRequest struct {
	ctx        context.Context
	ApiService *ProjectsApiService
	id         string
	projectPk  string
	asOf       *time.Time
	tag        *string
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;tag&#x60;.
func (r ApiProjectsParametersTimelineRetrieveRequest) AsOf(asOf time.Time) ApiProjectsParametersTimelineRetrieveRequest {
	r.asOf = &asOf
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsParametersTimelineRetrieveRequest) Tag(tag string) ApiProjectsParametersTimelineRetrieveRequest {
	r.tag = &tag
	return r
}

func (r ApiProjectsParametersTimelineRetrieveRequest) Execute() (*ParameterTimeline, *http.Response, error) {
	return r.ApiService.ProjectsParametersTimelineRetrieveExecute(r)
}

/*
ProjectsParametersTimelineRetrieve Method for ProjectsParametersTimelineRetrieve

Summary information about how a parameter has changed over time.

The time range of historical information available depends on your subscription.
Any changes to the parameter itself, including rules and values, is included.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param projectPk
	@return ApiProjectsParametersTimelineRetrieveRequest
*/
func (a *ProjectsApiService) ProjectsParametersTimelineRetrieve(ctx context.Context, id string, projectPk string) ApiProjectsParametersTimelineRetrieveRequest {
	return ApiProjectsParametersTimelineRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return ParameterTimeline
func (a *ProjectsApiService) ProjectsParametersTimelineRetrieveExecute(r ApiProjectsParametersTimelineRetrieveRequest) (*ParameterTimeline, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ParameterTimeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersTimelineRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{id}/timeline/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asOf != nil {
		localVarQueryParams.Add("as_of", parameterToString(*r.asOf, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersTimelinesRetrieveRequest struct {
	ctx        context.Context
	ApiService *ProjectsApiService
	projectPk  string
	asOf       *time.Time
	tag        *string
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;tag&#x60;.
func (r ApiProjectsParametersTimelinesRetrieveRequest) AsOf(asOf time.Time) ApiProjectsParametersTimelinesRetrieveRequest {
	r.asOf = &asOf
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsParametersTimelinesRetrieveRequest) Tag(tag string) ApiProjectsParametersTimelinesRetrieveRequest {
	r.tag = &tag
	return r
}

func (r ApiProjectsParametersTimelinesRetrieveRequest) Execute() (*ParameterTimeline, *http.Response, error) {
	return r.ApiService.ProjectsParametersTimelinesRetrieveExecute(r)
}

/*
ProjectsParametersTimelinesRetrieve Method for ProjectsParametersTimelinesRetrieve

Information about how the parameters of a project have changed over time.

The time range of historical information available depends on your subscription.
Any changes to the project's parameters, including rules and values, is included.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectPk
	@return ApiProjectsParametersTimelinesRetrieveRequest
*/
func (a *ProjectsApiService) ProjectsParametersTimelinesRetrieve(ctx context.Context, projectPk string) ApiProjectsParametersTimelinesRetrieveRequest {
	return ApiProjectsParametersTimelinesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return ParameterTimeline
func (a *ProjectsApiService) ProjectsParametersTimelinesRetrieveExecute(r ApiProjectsParametersTimelinesRetrieveRequest) (*ParameterTimeline, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ParameterTimeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersTimelinesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/timelines/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asOf != nil {
		localVarQueryParams.Add("as_of", parameterToString(*r.asOf, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersUpdateRequest struct {
	ctx        context.Context
	ApiService *ProjectsApiService
	id         string
	projectPk  string
	parameter  *Parameter
}

func (r ApiProjectsParametersUpdateRequest) Parameter(parameter Parameter) ApiProjectsParametersUpdateRequest {
	r.parameter = &parameter
	return r
}

func (r ApiProjectsParametersUpdateRequest) Execute() (*Parameter, *http.Response, error) {
	return r.ApiService.ProjectsParametersUpdateExecute(r)
}

/*
ProjectsParametersUpdate Method for ProjectsParametersUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param projectPk
	@return ApiProjectsParametersUpdateRequest
*/
func (a *ProjectsApiService) ProjectsParametersUpdate(ctx context.Context, id string, projectPk string) ApiProjectsParametersUpdateRequest {
	return ApiProjectsParametersUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return Parameter
func (a *ProjectsApiService) ProjectsParametersUpdateExecute(r ApiProjectsParametersUpdateRequest) (*Parameter, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Parameter
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.parameter == nil {
		return localVarReturnValue, nil, reportError("parameter is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.parameter
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersValuesCreateRequest struct {
	ctx         context.Context
	ApiService  *ProjectsApiService
	parameterPk string
	projectPk   string
	valueCreate *ValueCreate
	evaluate    *bool
	wrap        *bool
}

func (r ApiProjectsParametersValuesCreateRequest) ValueCreate(valueCreate ValueCreate) ApiProjectsParametersValuesCreateRequest {
	r.valueCreate = &valueCreate
	return r
}

// If &#x60;true&#x60;, runs template evaluation on this parameter.  If &#x60;false&#x60;, returns the value&#39;s template. No effect on values that are not interpolated.
func (r ApiProjectsParametersValuesCreateRequest) Evaluate(evaluate bool) ApiProjectsParametersValuesCreateRequest {
	r.evaluate = &evaluate
	return r
}

// Indicates the &#x60;internal_value&#x60; is a wrapped secret. For more information on secret wrapping, see the documentation.
func (r ApiProjectsParametersValuesCreateRequest) Wrap(wrap bool) ApiProjectsParametersValuesCreateRequest {
	r.wrap = &wrap
	return r
}

func (r ApiProjectsParametersValuesCreateRequest) Execute() (*Value, *http.Response, error) {
	return r.ApiService.ProjectsParametersValuesCreateExecute(r)
}

/*
ProjectsParametersValuesCreate Set a value.

Set the value of a parameter in an environment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param parameterPk The parameter id.
	@param projectPk The project id.
	@return ApiProjectsParametersValuesCreateRequest
*/
func (a *ProjectsApiService) ProjectsParametersValuesCreate(ctx context.Context, parameterPk string, projectPk string) ApiProjectsParametersValuesCreateRequest {
	return ApiProjectsParametersValuesCreateRequest{
		ApiService:  a,
		ctx:         ctx,
		parameterPk: parameterPk,
		projectPk:   projectPk,
	}
}

// Execute executes the request
//
//	@return Value
func (a *ProjectsApiService) ProjectsParametersValuesCreateExecute(r ApiProjectsParametersValuesCreateRequest) (*Value, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Value
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersValuesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{parameter_pk}/values/"
	localVarPath = strings.Replace(localVarPath, "{"+"parameter_pk"+"}", url.PathEscape(parameterToString(r.parameterPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.valueCreate == nil {
		return localVarReturnValue, nil, reportError("valueCreate is required and must be specified")
	}

	if r.evaluate != nil {
		localVarQueryParams.Add("evaluate", parameterToString(*r.evaluate, ""))
	}
	if r.wrap != nil {
		localVarQueryParams.Add("wrap", parameterToString(*r.wrap, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.valueCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersValuesDestroyRequest struct {
	ctx         context.Context
	ApiService  *ProjectsApiService
	id          string
	parameterPk string
	projectPk   string
	evaluate    *bool
}

// If &#x60;true&#x60;, runs template evaluation on this parameter.  If &#x60;false&#x60;, returns the value&#39;s template. No effect on values that are not interpolated.
func (r ApiProjectsParametersValuesDestroyRequest) Evaluate(evaluate bool) ApiProjectsParametersValuesDestroyRequest {
	r.evaluate = &evaluate
	return r
}

func (r ApiProjectsParametersValuesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectsParametersValuesDestroyExecute(r)
}

/*
ProjectsParametersValuesDestroy Destroy a value.

Destroy the value of a parameter in an environment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param parameterPk The parameter id.
	@param projectPk The project id.
	@return ApiProjectsParametersValuesDestroyRequest
*/
func (a *ProjectsApiService) ProjectsParametersValuesDestroy(ctx context.Context, id string, parameterPk string, projectPk string) ApiProjectsParametersValuesDestroyRequest {
	return ApiProjectsParametersValuesDestroyRequest{
		ApiService:  a,
		ctx:         ctx,
		id:          id,
		parameterPk: parameterPk,
		projectPk:   projectPk,
	}
}

// Execute executes the request
func (a *ProjectsApiService) ProjectsParametersValuesDestroyExecute(r ApiProjectsParametersValuesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersValuesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{parameter_pk}/values/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parameter_pk"+"}", url.PathEscape(parameterToString(r.parameterPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.evaluate != nil {
		localVarQueryParams.Add("evaluate", parameterToString(*r.evaluate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectsParametersValuesListRequest struct {
	ctx         context.Context
	ApiService  *ProjectsApiService
	parameterPk string
	projectPk   string
	asOf        *time.Time
	environment *string
	evaluate    *bool
	exclude     *string
	include     *string
	maskSecrets *bool
	page        *int32
	pageSize    *int32
	tag         *string
	wrap        *bool
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;tag&#x60;.
func (r ApiProjectsParametersValuesListRequest) AsOf(asOf time.Time) ApiProjectsParametersValuesListRequest {
	r.asOf = &asOf
	return r
}

// Name or id of the environment to limit the result to. If this is not specified then the result will contain a value for any environment in which it is set. You cannot use this option to retrieve the _effective_ value of a parameter in an environment for which is is not explicitly set. To see _effective_ values use the Parameters API (see the &#x60;values&#x60; field).
func (r ApiProjectsParametersValuesListRequest) Environment(environment string) ApiProjectsParametersValuesListRequest {
	r.environment = &environment
	return r
}

// If &#x60;true&#x60;, runs template evaluation on this parameter.  If &#x60;false&#x60;, returns the value&#39;s template. No effect on values that are not interpolated.
func (r ApiProjectsParametersValuesListRequest) Evaluate(evaluate bool) ApiProjectsParametersValuesListRequest {
	r.evaluate = &evaluate
	return r
}

// A comma-separated list of field names to exclude from the response.
func (r ApiProjectsParametersValuesListRequest) Exclude(exclude string) ApiProjectsParametersValuesListRequest {
	r.exclude = &exclude
	return r
}

// A comma-separated list of field names to include in the response.
func (r ApiProjectsParametersValuesListRequest) Include(include string) ApiProjectsParametersValuesListRequest {
	r.include = &include
	return r
}

// Mask secret values in responses with &#x60;*****&#x60;.
func (r ApiProjectsParametersValuesListRequest) MaskSecrets(maskSecrets bool) ApiProjectsParametersValuesListRequest {
	r.maskSecrets = &maskSecrets
	return r
}

// A page number within the paginated result set.
func (r ApiProjectsParametersValuesListRequest) Page(page int32) ApiProjectsParametersValuesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiProjectsParametersValuesListRequest) PageSize(pageSize int32) ApiProjectsParametersValuesListRequest {
	r.pageSize = &pageSize
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsParametersValuesListRequest) Tag(tag string) ApiProjectsParametersValuesListRequest {
	r.tag = &tag
	return r
}

// For writes, indicates &#x60;internal_value&#x60; is wrapped; for reads, indicates &#x60;value&#x60; is wrapped. For more information on secret wrapping, see the documentation.
func (r ApiProjectsParametersValuesListRequest) Wrap(wrap bool) ApiProjectsParametersValuesListRequest {
	r.wrap = &wrap
	return r
}

func (r ApiProjectsParametersValuesListRequest) Execute() (*PaginatedValueList, *http.Response, error) {
	return r.ApiService.ProjectsParametersValuesListExecute(r)
}

/*
ProjectsParametersValuesList Retrieve values.

	       Retrieve previously set values of a parameter in one or all environments.
	       To see all the _effective_ values for a parameter across every environment,
	       use the Parameters API (see the `values` field).


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param parameterPk The parameter id.
	@param projectPk The project id.
	@return ApiProjectsParametersValuesListRequest
*/
func (a *ProjectsApiService) ProjectsParametersValuesList(ctx context.Context, parameterPk string, projectPk string) ApiProjectsParametersValuesListRequest {
	return ApiProjectsParametersValuesListRequest{
		ApiService:  a,
		ctx:         ctx,
		parameterPk: parameterPk,
		projectPk:   projectPk,
	}
}

// Execute executes the request
//
//	@return PaginatedValueList
func (a *ProjectsApiService) ProjectsParametersValuesListExecute(r ApiProjectsParametersValuesListRequest) (*PaginatedValueList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedValueList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersValuesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{parameter_pk}/values/"
	localVarPath = strings.Replace(localVarPath, "{"+"parameter_pk"+"}", url.PathEscape(parameterToString(r.parameterPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asOf != nil {
		localVarQueryParams.Add("as_of", parameterToString(*r.asOf, ""))
	}
	if r.environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.environment, ""))
	}
	if r.evaluate != nil {
		localVarQueryParams.Add("evaluate", parameterToString(*r.evaluate, ""))
	}
	if r.exclude != nil {
		localVarQueryParams.Add("exclude", parameterToString(*r.exclude, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, ""))
	}
	if r.maskSecrets != nil {
		localVarQueryParams.Add("mask_secrets", parameterToString(*r.maskSecrets, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.wrap != nil {
		localVarQueryParams.Add("wrap", parameterToString(*r.wrap, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersValuesPartialUpdateRequest struct {
	ctx          context.Context
	ApiService   *ProjectsApiService
	id           string
	parameterPk  string
	projectPk    string
	evaluate     *bool
	wrap         *bool
	patchedValue *PatchedValue
}

// If &#x60;true&#x60;, runs template evaluation on this parameter.  If &#x60;false&#x60;, returns the value&#39;s template. No effect on values that are not interpolated.
func (r ApiProjectsParametersValuesPartialUpdateRequest) Evaluate(evaluate bool) ApiProjectsParametersValuesPartialUpdateRequest {
	r.evaluate = &evaluate
	return r
}

// Indicates the &#x60;internal_value&#x60; is a wrapped secret. For more information on secret wrapping, see the documentation.
func (r ApiProjectsParametersValuesPartialUpdateRequest) Wrap(wrap bool) ApiProjectsParametersValuesPartialUpdateRequest {
	r.wrap = &wrap
	return r
}

func (r ApiProjectsParametersValuesPartialUpdateRequest) PatchedValue(patchedValue PatchedValue) ApiProjectsParametersValuesPartialUpdateRequest {
	r.patchedValue = &patchedValue
	return r
}

func (r ApiProjectsParametersValuesPartialUpdateRequest) Execute() (*Value, *http.Response, error) {
	return r.ApiService.ProjectsParametersValuesPartialUpdateExecute(r)
}

/*
ProjectsParametersValuesPartialUpdate Update a value.

Update the value of a parameter in an environment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param parameterPk The parameter id.
	@param projectPk The project id.
	@return ApiProjectsParametersValuesPartialUpdateRequest
*/
func (a *ProjectsApiService) ProjectsParametersValuesPartialUpdate(ctx context.Context, id string, parameterPk string, projectPk string) ApiProjectsParametersValuesPartialUpdateRequest {
	return ApiProjectsParametersValuesPartialUpdateRequest{
		ApiService:  a,
		ctx:         ctx,
		id:          id,
		parameterPk: parameterPk,
		projectPk:   projectPk,
	}
}

// Execute executes the request
//
//	@return Value
func (a *ProjectsApiService) ProjectsParametersValuesPartialUpdateExecute(r ApiProjectsParametersValuesPartialUpdateRequest) (*Value, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Value
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersValuesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{parameter_pk}/values/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parameter_pk"+"}", url.PathEscape(parameterToString(r.parameterPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.evaluate != nil {
		localVarQueryParams.Add("evaluate", parameterToString(*r.evaluate, ""))
	}
	if r.wrap != nil {
		localVarQueryParams.Add("wrap", parameterToString(*r.wrap, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedValue
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersValuesRetrieveRequest struct {
	ctx         context.Context
	ApiService  *ProjectsApiService
	id          string
	parameterPk string
	projectPk   string
	asOf        *time.Time
	evaluate    *bool
	exclude     *string
	include     *string
	maskSecrets *bool
	tag         *string
	wrap        *bool
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;tag&#x60;.
func (r ApiProjectsParametersValuesRetrieveRequest) AsOf(asOf time.Time) ApiProjectsParametersValuesRetrieveRequest {
	r.asOf = &asOf
	return r
}

// If &#x60;true&#x60;, runs template evaluation on this parameter.  If &#x60;false&#x60;, returns the value&#39;s template. No effect on values that are not interpolated.
func (r ApiProjectsParametersValuesRetrieveRequest) Evaluate(evaluate bool) ApiProjectsParametersValuesRetrieveRequest {
	r.evaluate = &evaluate
	return r
}

// A comma-separated list of field names to exclude from the response.
func (r ApiProjectsParametersValuesRetrieveRequest) Exclude(exclude string) ApiProjectsParametersValuesRetrieveRequest {
	r.exclude = &exclude
	return r
}

// A comma-separated list of field names to include in the response.
func (r ApiProjectsParametersValuesRetrieveRequest) Include(include string) ApiProjectsParametersValuesRetrieveRequest {
	r.include = &include
	return r
}

// Mask secret values in responses with &#x60;*****&#x60;.
func (r ApiProjectsParametersValuesRetrieveRequest) MaskSecrets(maskSecrets bool) ApiProjectsParametersValuesRetrieveRequest {
	r.maskSecrets = &maskSecrets
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsParametersValuesRetrieveRequest) Tag(tag string) ApiProjectsParametersValuesRetrieveRequest {
	r.tag = &tag
	return r
}

// For writes, indicates &#x60;internal_value&#x60; is wrapped; for reads, indicates &#x60;value&#x60; is wrapped. For more information on secret wrapping, see the documentation.
func (r ApiProjectsParametersValuesRetrieveRequest) Wrap(wrap bool) ApiProjectsParametersValuesRetrieveRequest {
	r.wrap = &wrap
	return r
}

func (r ApiProjectsParametersValuesRetrieveRequest) Execute() (*Value, *http.Response, error) {
	return r.ApiService.ProjectsParametersValuesRetrieveExecute(r)
}

/*
ProjectsParametersValuesRetrieve Retrieve a value.

Retrieve the value of a parameter in an environment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param parameterPk The parameter id.
	@param projectPk The project id.
	@return ApiProjectsParametersValuesRetrieveRequest
*/
func (a *ProjectsApiService) ProjectsParametersValuesRetrieve(ctx context.Context, id string, parameterPk string, projectPk string) ApiProjectsParametersValuesRetrieveRequest {
	return ApiProjectsParametersValuesRetrieveRequest{
		ApiService:  a,
		ctx:         ctx,
		id:          id,
		parameterPk: parameterPk,
		projectPk:   projectPk,
	}
}

// Execute executes the request
//
//	@return Value
func (a *ProjectsApiService) ProjectsParametersValuesRetrieveExecute(r ApiProjectsParametersValuesRetrieveRequest) (*Value, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Value
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersValuesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{parameter_pk}/values/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parameter_pk"+"}", url.PathEscape(parameterToString(r.parameterPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asOf != nil {
		localVarQueryParams.Add("as_of", parameterToString(*r.asOf, ""))
	}
	if r.evaluate != nil {
		localVarQueryParams.Add("evaluate", parameterToString(*r.evaluate, ""))
	}
	if r.exclude != nil {
		localVarQueryParams.Add("exclude", parameterToString(*r.exclude, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, ""))
	}
	if r.maskSecrets != nil {
		localVarQueryParams.Add("mask_secrets", parameterToString(*r.maskSecrets, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.wrap != nil {
		localVarQueryParams.Add("wrap", parameterToString(*r.wrap, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsParametersValuesUpdateRequest struct {
	ctx         context.Context
	ApiService  *ProjectsApiService
	id          string
	parameterPk string
	projectPk   string
	evaluate    *bool
	wrap        *bool
	value       *Value
}

// If &#x60;true&#x60;, runs template evaluation on this parameter.  If &#x60;false&#x60;, returns the value&#39;s template. No effect on values that are not interpolated.
func (r ApiProjectsParametersValuesUpdateRequest) Evaluate(evaluate bool) ApiProjectsParametersValuesUpdateRequest {
	r.evaluate = &evaluate
	return r
}

// Indicates the &#x60;internal_value&#x60; is a wrapped secret. For more information on secret wrapping, see the documentation.
func (r ApiProjectsParametersValuesUpdateRequest) Wrap(wrap bool) ApiProjectsParametersValuesUpdateRequest {
	r.wrap = &wrap
	return r
}

func (r ApiProjectsParametersValuesUpdateRequest) Value(value Value) ApiProjectsParametersValuesUpdateRequest {
	r.value = &value
	return r
}

func (r ApiProjectsParametersValuesUpdateRequest) Execute() (*Value, *http.Response, error) {
	return r.ApiService.ProjectsParametersValuesUpdateExecute(r)
}

/*
ProjectsParametersValuesUpdate Update a value.

Update the value of a parameter in an environment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param parameterPk The parameter id.
	@param projectPk The project id.
	@return ApiProjectsParametersValuesUpdateRequest
*/
func (a *ProjectsApiService) ProjectsParametersValuesUpdate(ctx context.Context, id string, parameterPk string, projectPk string) ApiProjectsParametersValuesUpdateRequest {
	return ApiProjectsParametersValuesUpdateRequest{
		ApiService:  a,
		ctx:         ctx,
		id:          id,
		parameterPk: parameterPk,
		projectPk:   projectPk,
	}
}

// Execute executes the request
//
//	@return Value
func (a *ProjectsApiService) ProjectsParametersValuesUpdateExecute(r ApiProjectsParametersValuesUpdateRequest) (*Value, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Value
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsParametersValuesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/parameters/{parameter_pk}/values/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parameter_pk"+"}", url.PathEscape(parameterToString(r.parameterPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.evaluate != nil {
		localVarQueryParams.Add("evaluate", parameterToString(*r.evaluate, ""))
	}
	if r.wrap != nil {
		localVarQueryParams.Add("wrap", parameterToString(*r.wrap, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.value
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsPartialUpdateRequest struct {
	ctx            context.Context
	ApiService     *ProjectsApiService
	id             string
	patchedProject *PatchedProject
}

func (r ApiProjectsPartialUpdateRequest) PatchedProject(patchedProject PatchedProject) ApiProjectsPartialUpdateRequest {
	r.patchedProject = &patchedProject
	return r
}

func (r ApiProjectsPartialUpdateRequest) Execute() (*Project, *http.Response, error) {
	return r.ApiService.ProjectsPartialUpdateExecute(r)
}

/*
ProjectsPartialUpdate Method for ProjectsPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiProjectsPartialUpdateRequest
*/
func (a *ProjectsApiService) ProjectsPartialUpdate(ctx context.Context, id string) ApiProjectsPartialUpdateRequest {
	return ApiProjectsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Project
func (a *ProjectsApiService) ProjectsPartialUpdateExecute(r ApiProjectsPartialUpdateRequest) (*Project, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Project
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedProject
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsRetrieveRequest struct {
	ctx        context.Context
	ApiService *ProjectsApiService
	id         string
}

func (r ApiProjectsRetrieveRequest) Execute() (*Project, *http.Response, error) {
	return r.ApiService.ProjectsRetrieveExecute(r)
}

/*
ProjectsRetrieve Method for ProjectsRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiProjectsRetrieveRequest
*/
func (a *ProjectsApiService) ProjectsRetrieve(ctx context.Context, id string) ApiProjectsRetrieveRequest {
	return ApiProjectsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Project
func (a *ProjectsApiService) ProjectsRetrieveExecute(r ApiProjectsRetrieveRequest) (*Project, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Project
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsTemplatePreviewCreateRequest struct {
	ctx                          context.Context
	ApiService                   *ProjectsApiService
	projectPk                    string
	templatePreviewCreateRequest *TemplatePreviewCreateRequest
	asOf                         *time.Time
	environment                  *string
	maskSecrets                  *bool
	tag                          *string
	template                     *string
}

func (r ApiProjectsTemplatePreviewCreateRequest) TemplatePreviewCreateRequest(templatePreviewCreateRequest TemplatePreviewCreateRequest) ApiProjectsTemplatePreviewCreateRequest {
	r.templatePreviewCreateRequest = &templatePreviewCreateRequest
	return r
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;tag&#x60;.
func (r ApiProjectsTemplatePreviewCreateRequest) AsOf(asOf time.Time) ApiProjectsTemplatePreviewCreateRequest {
	r.asOf = &asOf
	return r
}

// Name or id of the environment to use to instantiate this template. If not specified then the default environment is used.
func (r ApiProjectsTemplatePreviewCreateRequest) Environment(environment string) ApiProjectsTemplatePreviewCreateRequest {
	r.environment = &environment
	return r
}

// Masks all secrets in the template with &#x60;*****&#x60;.
func (r ApiProjectsTemplatePreviewCreateRequest) MaskSecrets(maskSecrets bool) ApiProjectsTemplatePreviewCreateRequest {
	r.maskSecrets = &maskSecrets
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsTemplatePreviewCreateRequest) Tag(tag string) ApiProjectsTemplatePreviewCreateRequest {
	r.tag = &tag
	return r
}

// ID of the template parameter being previewed.  If not specified, this is assumed to be a not-yet-created parameter.
func (r ApiProjectsTemplatePreviewCreateRequest) Template(template string) ApiProjectsTemplatePreviewCreateRequest {
	r.template = &template
	return r
}

func (r ApiProjectsTemplatePreviewCreateRequest) Execute() (*TemplatePreview, *http.Response, error) {
	return r.ApiService.ProjectsTemplatePreviewCreateExecute(r)
}

/*
ProjectsTemplatePreviewCreate Method for ProjectsTemplatePreviewCreate

Endpoint for previewing a template.  Post the template content in the request body.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectPk
	@return ApiProjectsTemplatePreviewCreateRequest
*/
func (a *ProjectsApiService) ProjectsTemplatePreviewCreate(ctx context.Context, projectPk string) ApiProjectsTemplatePreviewCreateRequest {
	return ApiProjectsTemplatePreviewCreateRequest{
		ApiService: a,
		ctx:        ctx,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return TemplatePreview
func (a *ProjectsApiService) ProjectsTemplatePreviewCreateExecute(r ApiProjectsTemplatePreviewCreateRequest) (*TemplatePreview, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TemplatePreview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsTemplatePreviewCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/template-preview/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.templatePreviewCreateRequest == nil {
		return localVarReturnValue, nil, reportError("templatePreviewCreateRequest is required and must be specified")
	}

	if r.asOf != nil {
		localVarQueryParams.Add("as_of", parameterToString(*r.asOf, ""))
	}
	if r.environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.environment, ""))
	}
	if r.maskSecrets != nil {
		localVarQueryParams.Add("mask_secrets", parameterToString(*r.maskSecrets, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	if r.template != nil {
		localVarQueryParams.Add("template", parameterToString(*r.template, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.templatePreviewCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v TemplateLookupError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsTemplatesCreateRequest struct {
	ctx            context.Context
	ApiService     *ProjectsApiService
	projectPk      string
	templateCreate *TemplateCreate
}

func (r ApiProjectsTemplatesCreateRequest) TemplateCreate(templateCreate TemplateCreate) ApiProjectsTemplatesCreateRequest {
	r.templateCreate = &templateCreate
	return r
}

func (r ApiProjectsTemplatesCreateRequest) Execute() (*Template, *http.Response, error) {
	return r.ApiService.ProjectsTemplatesCreateExecute(r)
}

/*
ProjectsTemplatesCreate Method for ProjectsTemplatesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectPk
	@return ApiProjectsTemplatesCreateRequest
*/
func (a *ProjectsApiService) ProjectsTemplatesCreate(ctx context.Context, projectPk string) ApiProjectsTemplatesCreateRequest {
	return ApiProjectsTemplatesCreateRequest{
		ApiService: a,
		ctx:        ctx,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return Template
func (a *ProjectsApiService) ProjectsTemplatesCreateExecute(r ApiProjectsTemplatesCreateRequest) (*Template, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Template
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/templates/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.templateCreate == nil {
		return localVarReturnValue, nil, reportError("templateCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.templateCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v TemplateLookupError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsTemplatesDestroyRequest struct {
	ctx        context.Context
	ApiService *ProjectsApiService
	id         string
	projectPk  string
}

func (r ApiProjectsTemplatesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectsTemplatesDestroyExecute(r)
}

/*
ProjectsTemplatesDestroy Method for ProjectsTemplatesDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param projectPk
	@return ApiProjectsTemplatesDestroyRequest
*/
func (a *ProjectsApiService) ProjectsTemplatesDestroy(ctx context.Context, id string, projectPk string) ApiProjectsTemplatesDestroyRequest {
	return ApiProjectsTemplatesDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		projectPk:  projectPk,
	}
}

// Execute executes the request
func (a *ProjectsApiService) ProjectsTemplatesDestroyExecute(r ApiProjectsTemplatesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsTemplatesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectsTemplatesListRequest struct {
	ctx         context.Context
	ApiService  *ProjectsApiService
	projectPk   string
	asOf        *time.Time
	environment *string
	evaluate    *bool
	maskSecrets *bool
	name        *string
	ordering    *string
	page        *int32
	pageSize    *int32
	tag         *string
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;tag&#x60;.
func (r ApiProjectsTemplatesListRequest) AsOf(asOf time.Time) ApiProjectsTemplatesListRequest {
	r.asOf = &asOf
	return r
}

// Name or id of the environment to use to evaluate this template. If not specified then the original content is returned in the body.
func (r ApiProjectsTemplatesListRequest) Environment(environment string) ApiProjectsTemplatesListRequest {
	r.environment = &environment
	return r
}

// If &#x60;true&#x60;, evaluates the template&#39;s body.  If &#x60;false&#x60;, returns the unevaluated template body.
func (r ApiProjectsTemplatesListRequest) Evaluate(evaluate bool) ApiProjectsTemplatesListRequest {
	r.evaluate = &evaluate
	return r
}

// Masks all secrets in the template with &#x60;*****&#x60;.
func (r ApiProjectsTemplatesListRequest) MaskSecrets(maskSecrets bool) ApiProjectsTemplatesListRequest {
	r.maskSecrets = &maskSecrets
	return r
}

func (r ApiProjectsTemplatesListRequest) Name(name string) ApiProjectsTemplatesListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiProjectsTemplatesListRequest) Ordering(ordering string) ApiProjectsTemplatesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiProjectsTemplatesListRequest) Page(page int32) ApiProjectsTemplatesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiProjectsTemplatesListRequest) PageSize(pageSize int32) ApiProjectsTemplatesListRequest {
	r.pageSize = &pageSize
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsTemplatesListRequest) Tag(tag string) ApiProjectsTemplatesListRequest {
	r.tag = &tag
	return r
}

func (r ApiProjectsTemplatesListRequest) Execute() (*PaginatedTemplateList, *http.Response, error) {
	return r.ApiService.ProjectsTemplatesListExecute(r)
}

/*
ProjectsTemplatesList Method for ProjectsTemplatesList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectPk
	@return ApiProjectsTemplatesListRequest
*/
func (a *ProjectsApiService) ProjectsTemplatesList(ctx context.Context, projectPk string) ApiProjectsTemplatesListRequest {
	return ApiProjectsTemplatesListRequest{
		ApiService: a,
		ctx:        ctx,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return PaginatedTemplateList
func (a *ProjectsApiService) ProjectsTemplatesListExecute(r ApiProjectsTemplatesListRequest) (*PaginatedTemplateList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedTemplateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/templates/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asOf != nil {
		localVarQueryParams.Add("as_of", parameterToString(*r.asOf, ""))
	}
	if r.environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.environment, ""))
	}
	if r.evaluate != nil {
		localVarQueryParams.Add("evaluate", parameterToString(*r.evaluate, ""))
	}
	if r.maskSecrets != nil {
		localVarQueryParams.Add("mask_secrets", parameterToString(*r.maskSecrets, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v TemplateLookupError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsTemplatesPartialUpdateRequest struct {
	ctx             context.Context
	ApiService      *ProjectsApiService
	id              string
	projectPk       string
	patchedTemplate *PatchedTemplate
}

func (r ApiProjectsTemplatesPartialUpdateRequest) PatchedTemplate(patchedTemplate PatchedTemplate) ApiProjectsTemplatesPartialUpdateRequest {
	r.patchedTemplate = &patchedTemplate
	return r
}

func (r ApiProjectsTemplatesPartialUpdateRequest) Execute() (*Template, *http.Response, error) {
	return r.ApiService.ProjectsTemplatesPartialUpdateExecute(r)
}

/*
ProjectsTemplatesPartialUpdate Method for ProjectsTemplatesPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param projectPk
	@return ApiProjectsTemplatesPartialUpdateRequest
*/
func (a *ProjectsApiService) ProjectsTemplatesPartialUpdate(ctx context.Context, id string, projectPk string) ApiProjectsTemplatesPartialUpdateRequest {
	return ApiProjectsTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return Template
func (a *ProjectsApiService) ProjectsTemplatesPartialUpdateExecute(r ApiProjectsTemplatesPartialUpdateRequest) (*Template, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Template
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTemplate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v TemplateLookupError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsTemplatesRetrieveRequest struct {
	ctx         context.Context
	ApiService  *ProjectsApiService
	id          string
	projectPk   string
	asOf        *time.Time
	environment *string
	evaluate    *bool
	maskSecrets *bool
	tag         *string
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;tag&#x60;.
func (r ApiProjectsTemplatesRetrieveRequest) AsOf(asOf time.Time) ApiProjectsTemplatesRetrieveRequest {
	r.asOf = &asOf
	return r
}

// Name or id of the environment to use to evaluate this template. If not specified then the original content is returned in the body.
func (r ApiProjectsTemplatesRetrieveRequest) Environment(environment string) ApiProjectsTemplatesRetrieveRequest {
	r.environment = &environment
	return r
}

// If &#x60;true&#x60;, evaluates the template&#39;s body.  If &#x60;false&#x60;, returns the unevaluated template body.
func (r ApiProjectsTemplatesRetrieveRequest) Evaluate(evaluate bool) ApiProjectsTemplatesRetrieveRequest {
	r.evaluate = &evaluate
	return r
}

// Masks all secrets in the template with &#x60;*****&#x60;.
func (r ApiProjectsTemplatesRetrieveRequest) MaskSecrets(maskSecrets bool) ApiProjectsTemplatesRetrieveRequest {
	r.maskSecrets = &maskSecrets
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsTemplatesRetrieveRequest) Tag(tag string) ApiProjectsTemplatesRetrieveRequest {
	r.tag = &tag
	return r
}

func (r ApiProjectsTemplatesRetrieveRequest) Execute() (*Template, *http.Response, error) {
	return r.ApiService.ProjectsTemplatesRetrieveExecute(r)
}

/*
ProjectsTemplatesRetrieve Method for ProjectsTemplatesRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param projectPk
	@return ApiProjectsTemplatesRetrieveRequest
*/
func (a *ProjectsApiService) ProjectsTemplatesRetrieve(ctx context.Context, id string, projectPk string) ApiProjectsTemplatesRetrieveRequest {
	return ApiProjectsTemplatesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return Template
func (a *ProjectsApiService) ProjectsTemplatesRetrieveExecute(r ApiProjectsTemplatesRetrieveRequest) (*Template, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Template
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsTemplatesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asOf != nil {
		localVarQueryParams.Add("as_of", parameterToString(*r.asOf, ""))
	}
	if r.environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.environment, ""))
	}
	if r.evaluate != nil {
		localVarQueryParams.Add("evaluate", parameterToString(*r.evaluate, ""))
	}
	if r.maskSecrets != nil {
		localVarQueryParams.Add("mask_secrets", parameterToString(*r.maskSecrets, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v TemplateLookupError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsTemplatesTimelineRetrieveRequest struct {
	ctx         context.Context
	ApiService  *ProjectsApiService
	id          string
	projectPk   string
	asOf        *time.Time
	environment *string
	tag         *string
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;tag&#x60;.
func (r ApiProjectsTemplatesTimelineRetrieveRequest) AsOf(asOf time.Time) ApiProjectsTemplatesTimelineRetrieveRequest {
	r.asOf = &asOf
	return r
}

// Name or id of the environment to use to evaluate this template. If not specified then the original content is returned in the body.
func (r ApiProjectsTemplatesTimelineRetrieveRequest) Environment(environment string) ApiProjectsTemplatesTimelineRetrieveRequest {
	r.environment = &environment
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsTemplatesTimelineRetrieveRequest) Tag(tag string) ApiProjectsTemplatesTimelineRetrieveRequest {
	r.tag = &tag
	return r
}

func (r ApiProjectsTemplatesTimelineRetrieveRequest) Execute() (*TemplateTimeline, *http.Response, error) {
	return r.ApiService.ProjectsTemplatesTimelineRetrieveExecute(r)
}

/*
ProjectsTemplatesTimelineRetrieve Method for ProjectsTemplatesTimelineRetrieve

Information about how a template has changed over time.

The time range of historical information available depends on your subscription.
Any changes to the template itself is included.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param projectPk
	@return ApiProjectsTemplatesTimelineRetrieveRequest
*/
func (a *ProjectsApiService) ProjectsTemplatesTimelineRetrieve(ctx context.Context, id string, projectPk string) ApiProjectsTemplatesTimelineRetrieveRequest {
	return ApiProjectsTemplatesTimelineRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return TemplateTimeline
func (a *ProjectsApiService) ProjectsTemplatesTimelineRetrieveExecute(r ApiProjectsTemplatesTimelineRetrieveRequest) (*TemplateTimeline, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TemplateTimeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsTemplatesTimelineRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/templates/{id}/timeline/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asOf != nil {
		localVarQueryParams.Add("as_of", parameterToString(*r.asOf, ""))
	}
	if r.environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.environment, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsTemplatesTimelinesRetrieveRequest struct {
	ctx         context.Context
	ApiService  *ProjectsApiService
	projectPk   string
	asOf        *time.Time
	environment *string
	tag         *string
}

// Specify a point in time to retrieve configuration from. Cannot be specified with &#x60;tag&#x60;.
func (r ApiProjectsTemplatesTimelinesRetrieveRequest) AsOf(asOf time.Time) ApiProjectsTemplatesTimelinesRetrieveRequest {
	r.asOf = &asOf
	return r
}

// Name or id of the environment to use to evaluate this template. If not specified then the original content is returned in the body.
func (r ApiProjectsTemplatesTimelinesRetrieveRequest) Environment(environment string) ApiProjectsTemplatesTimelinesRetrieveRequest {
	r.environment = &environment
	return r
}

// Specify a tag to retrieve configuration from. Cannot be specified with &#x60;as_of&#x60;. Requires &#x60;environment&#x60;.
func (r ApiProjectsTemplatesTimelinesRetrieveRequest) Tag(tag string) ApiProjectsTemplatesTimelinesRetrieveRequest {
	r.tag = &tag
	return r
}

func (r ApiProjectsTemplatesTimelinesRetrieveRequest) Execute() (*TemplateTimeline, *http.Response, error) {
	return r.ApiService.ProjectsTemplatesTimelinesRetrieveExecute(r)
}

/*
ProjectsTemplatesTimelinesRetrieve Method for ProjectsTemplatesTimelinesRetrieve

Information about how the templates of a project have changed over time.

The time range of historical information available depends on your subscription.
Any changes to the project's templates is included.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectPk
	@return ApiProjectsTemplatesTimelinesRetrieveRequest
*/
func (a *ProjectsApiService) ProjectsTemplatesTimelinesRetrieve(ctx context.Context, projectPk string) ApiProjectsTemplatesTimelinesRetrieveRequest {
	return ApiProjectsTemplatesTimelinesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return TemplateTimeline
func (a *ProjectsApiService) ProjectsTemplatesTimelinesRetrieveExecute(r ApiProjectsTemplatesTimelinesRetrieveRequest) (*TemplateTimeline, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TemplateTimeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsTemplatesTimelinesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/templates/timelines/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asOf != nil {
		localVarQueryParams.Add("as_of", parameterToString(*r.asOf, ""))
	}
	if r.environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.environment, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsTemplatesUpdateRequest struct {
	ctx        context.Context
	ApiService *ProjectsApiService
	id         string
	projectPk  string
	template   *Template
}

func (r ApiProjectsTemplatesUpdateRequest) Template(template Template) ApiProjectsTemplatesUpdateRequest {
	r.template = &template
	return r
}

func (r ApiProjectsTemplatesUpdateRequest) Execute() (*Template, *http.Response, error) {
	return r.ApiService.ProjectsTemplatesUpdateExecute(r)
}

/*
ProjectsTemplatesUpdate Method for ProjectsTemplatesUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param projectPk
	@return ApiProjectsTemplatesUpdateRequest
*/
func (a *ProjectsApiService) ProjectsTemplatesUpdate(ctx context.Context, id string, projectPk string) ApiProjectsTemplatesUpdateRequest {
	return ApiProjectsTemplatesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		projectPk:  projectPk,
	}
}

// Execute executes the request
//
//	@return Template
func (a *ProjectsApiService) ProjectsTemplatesUpdateExecute(r ApiProjectsTemplatesUpdateRequest) (*Template, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Template
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{project_pk}/templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_pk"+"}", url.PathEscape(parameterToString(r.projectPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.template == nil {
		return localVarReturnValue, nil, reportError("template is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.template
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v TemplateLookupError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsUpdateRequest struct {
	ctx        context.Context
	ApiService *ProjectsApiService
	id         string
	project    *Project
}

func (r ApiProjectsUpdateRequest) Project(project Project) ApiProjectsUpdateRequest {
	r.project = &project
	return r
}

func (r ApiProjectsUpdateRequest) Execute() (*Project, *http.Response, error) {
	return r.ApiService.ProjectsUpdateExecute(r)
}

/*
ProjectsUpdate Method for ProjectsUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiProjectsUpdateRequest
*/
func (a *ProjectsApiService) ProjectsUpdate(ctx context.Context, id string) ApiProjectsUpdateRequest {
	return ApiProjectsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Project
func (a *ProjectsApiService) ProjectsUpdateExecute(r ApiProjectsUpdateRequest) (*Project, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Project
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.ProjectsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/projects/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.project == nil {
		return localVarReturnValue, nil, reportError("project is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.project
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
