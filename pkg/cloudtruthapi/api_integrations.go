/*
CloudTruth Management API

CloudTruth centralizes your configuration parameters and secrets making them easier to manage and use as a team.

API version: v1
Contact: support@cloudtruth.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cloudtruthapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// IntegrationsApiService IntegrationsApi service
type IntegrationsApiService service

type ApiIntegrationsAwsCreateRequest struct {
	ctx                  context.Context
	ApiService           *IntegrationsApiService
	awsIntegrationCreate *AwsIntegrationCreate
}

func (r ApiIntegrationsAwsCreateRequest) AwsIntegrationCreate(awsIntegrationCreate AwsIntegrationCreate) ApiIntegrationsAwsCreateRequest {
	r.awsIntegrationCreate = &awsIntegrationCreate
	return r
}

func (r ApiIntegrationsAwsCreateRequest) Execute() (*AwsIntegration, *http.Response, error) {
	return r.ApiService.IntegrationsAwsCreateExecute(r)
}

/*
IntegrationsAwsCreate Establishes an AWS Integration.

### Description ###

Establishes an AWS Integration for your CloudTruth organization.

### Pre-Conditions ###

- An AWS Integration for the account and role cannot already exist.
### Post-Conditions ###

- You must establish an IAM role and trust relationship based on the Role Name and the External ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntegrationsAwsCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsCreate(ctx context.Context) ApiIntegrationsAwsCreateRequest {
	return ApiIntegrationsAwsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return AwsIntegration
func (a *IntegrationsApiService) IntegrationsAwsCreateExecute(r ApiIntegrationsAwsCreateRequest) (*AwsIntegration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.awsIntegrationCreate == nil {
		return localVarReturnValue, nil, reportError("awsIntegrationCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsIntegrationCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsDestroyRequest struct {
	ctx        context.Context
	ApiService *IntegrationsApiService
	id         string
	inUse      *string
}

// (Optional) Desired behavior if the integration has in-use values.  - &#x60;fail&#x60; will return HTTP error 409 if there are any values using the integration. - &#x60;leave&#x60; (default) will leave values in place and future queries may fail; you can control future value query behavior with the &#x60;lookup_error&#x60; query parameter on those requests. - &#x60;remove&#x60; will remove the all values using the integration when the integration is removed.
func (r ApiIntegrationsAwsDestroyRequest) InUse(inUse string) ApiIntegrationsAwsDestroyRequest {
	r.inUse = &inUse
	return r
}

func (r ApiIntegrationsAwsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationsAwsDestroyExecute(r)
}

/*
IntegrationsAwsDestroy Delete an AWS integration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsAwsDestroyRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsDestroy(ctx context.Context, id string) ApiIntegrationsAwsDestroyRequest {
	return ApiIntegrationsAwsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAwsDestroyExecute(r ApiIntegrationsAwsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inUse != nil {
		localVarQueryParams.Add("in_use", parameterToString(*r.inUse, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAwsListRequest struct {
	ctx          context.Context
	ApiService   *IntegrationsApiService
	awsAccountId *string
	awsRoleName  *string
	ordering     *string
	page         *int32
	pageSize     *int32
}

func (r ApiIntegrationsAwsListRequest) AwsAccountId(awsAccountId string) ApiIntegrationsAwsListRequest {
	r.awsAccountId = &awsAccountId
	return r
}

func (r ApiIntegrationsAwsListRequest) AwsRoleName(awsRoleName string) ApiIntegrationsAwsListRequest {
	r.awsRoleName = &awsRoleName
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAwsListRequest) Ordering(ordering string) ApiIntegrationsAwsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAwsListRequest) Page(page int32) ApiIntegrationsAwsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAwsListRequest) PageSize(pageSize int32) ApiIntegrationsAwsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsAwsListRequest) Execute() (*PaginatedAwsIntegrationList, *http.Response, error) {
	return r.ApiService.IntegrationsAwsListExecute(r)
}

/*
IntegrationsAwsList Method for IntegrationsAwsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntegrationsAwsListRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsList(ctx context.Context) ApiIntegrationsAwsListRequest {
	return ApiIntegrationsAwsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedAwsIntegrationList
func (a *IntegrationsApiService) IntegrationsAwsListExecute(r ApiIntegrationsAwsListRequest) (*PaginatedAwsIntegrationList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAwsIntegrationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.awsAccountId != nil {
		localVarQueryParams.Add("aws_account_id", parameterToString(*r.awsAccountId, ""))
	}
	if r.awsRoleName != nil {
		localVarQueryParams.Add("aws_role_name", parameterToString(*r.awsRoleName, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPartialUpdateRequest struct {
	ctx                   context.Context
	ApiService            *IntegrationsApiService
	id                    string
	patchedAwsIntegration *PatchedAwsIntegration
}

func (r ApiIntegrationsAwsPartialUpdateRequest) PatchedAwsIntegration(patchedAwsIntegration PatchedAwsIntegration) ApiIntegrationsAwsPartialUpdateRequest {
	r.patchedAwsIntegration = &patchedAwsIntegration
	return r
}

func (r ApiIntegrationsAwsPartialUpdateRequest) Execute() (*AwsIntegration, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPartialUpdateExecute(r)
}

/*
IntegrationsAwsPartialUpdate Method for IntegrationsAwsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsAwsPartialUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPartialUpdate(ctx context.Context, id string) ApiIntegrationsAwsPartialUpdateRequest {
	return ApiIntegrationsAwsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return AwsIntegration
func (a *IntegrationsApiService) IntegrationsAwsPartialUpdateExecute(r ApiIntegrationsAwsPartialUpdateRequest) (*AwsIntegration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAwsIntegration
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsCreateRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awsPull          *AwsPull
}

func (r ApiIntegrationsAwsPullsCreateRequest) AwsPull(awsPull AwsPull) ApiIntegrationsAwsPullsCreateRequest {
	r.awsPull = &awsPull
	return r
}

func (r ApiIntegrationsAwsPullsCreateRequest) Execute() (*AwsPull, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPullsCreateExecute(r)
}

/*
IntegrationsAwsPullsCreate Method for IntegrationsAwsPullsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @return ApiIntegrationsAwsPullsCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsCreate(ctx context.Context, awsintegrationPk string) ApiIntegrationsAwsPullsCreateRequest {
	return ApiIntegrationsAwsPullsCreateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
	}
}

// Execute executes the request
//  @return AwsPull
func (a *IntegrationsApiService) IntegrationsAwsPullsCreateExecute(r ApiIntegrationsAwsPullsCreateRequest) (*AwsPull, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.awsPull == nil {
		return localVarReturnValue, nil, reportError("awsPull is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsPull
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsDestroyRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
}

func (r ApiIntegrationsAwsPullsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationsAwsPullsDestroyExecute(r)
}

/*
IntegrationsAwsPullsDestroy Method for IntegrationsAwsPullsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPullsDestroyRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsDestroy(ctx context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPullsDestroyRequest {
	return ApiIntegrationsAwsPullsDestroyRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAwsPullsDestroyExecute(r ApiIntegrationsAwsPullsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsListRequest struct {
	ctx                  context.Context
	ApiService           *IntegrationsApiService
	awsintegrationPk     string
	descriptionIcontains *string
	name                 *string
	nameIcontains        *string
	ordering             *string
	page                 *int32
	pageSize             *int32
}

func (r ApiIntegrationsAwsPullsListRequest) DescriptionIcontains(descriptionIcontains string) ApiIntegrationsAwsPullsListRequest {
	r.descriptionIcontains = &descriptionIcontains
	return r
}

func (r ApiIntegrationsAwsPullsListRequest) Name(name string) ApiIntegrationsAwsPullsListRequest {
	r.name = &name
	return r
}

func (r ApiIntegrationsAwsPullsListRequest) NameIcontains(nameIcontains string) ApiIntegrationsAwsPullsListRequest {
	r.nameIcontains = &nameIcontains
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAwsPullsListRequest) Ordering(ordering string) ApiIntegrationsAwsPullsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAwsPullsListRequest) Page(page int32) ApiIntegrationsAwsPullsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAwsPullsListRequest) PageSize(pageSize int32) ApiIntegrationsAwsPullsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsAwsPullsListRequest) Execute() (*PaginatedAwsPullList, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPullsListExecute(r)
}

/*
IntegrationsAwsPullsList Method for IntegrationsAwsPullsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @return ApiIntegrationsAwsPullsListRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsList(ctx context.Context, awsintegrationPk string) ApiIntegrationsAwsPullsListRequest {
	return ApiIntegrationsAwsPullsListRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
	}
}

// Execute executes the request
//  @return PaginatedAwsPullList
func (a *IntegrationsApiService) IntegrationsAwsPullsListExecute(r ApiIntegrationsAwsPullsListRequest) (*PaginatedAwsPullList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAwsPullList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.descriptionIcontains != nil {
		localVarQueryParams.Add("description__icontains", parameterToString(*r.descriptionIcontains, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameIcontains != nil {
		localVarQueryParams.Add("name__icontains", parameterToString(*r.nameIcontains, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsPartialUpdateRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
	patchedAwsPull   *PatchedAwsPull
}

func (r ApiIntegrationsAwsPullsPartialUpdateRequest) PatchedAwsPull(patchedAwsPull PatchedAwsPull) ApiIntegrationsAwsPullsPartialUpdateRequest {
	r.patchedAwsPull = &patchedAwsPull
	return r
}

func (r ApiIntegrationsAwsPullsPartialUpdateRequest) Execute() (*AwsPull, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPullsPartialUpdateExecute(r)
}

/*
IntegrationsAwsPullsPartialUpdate Method for IntegrationsAwsPullsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPullsPartialUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsPartialUpdate(ctx context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPullsPartialUpdateRequest {
	return ApiIntegrationsAwsPullsPartialUpdateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPull
func (a *IntegrationsApiService) IntegrationsAwsPullsPartialUpdateExecute(r ApiIntegrationsAwsPullsPartialUpdateRequest) (*AwsPull, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAwsPull
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsRetrieveRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
}

func (r ApiIntegrationsAwsPullsRetrieveRequest) Execute() (*AwsPull, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPullsRetrieveExecute(r)
}

/*
IntegrationsAwsPullsRetrieve Method for IntegrationsAwsPullsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPullsRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsRetrieve(ctx context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPullsRetrieveRequest {
	return ApiIntegrationsAwsPullsRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPull
func (a *IntegrationsApiService) IntegrationsAwsPullsRetrieveExecute(r ApiIntegrationsAwsPullsRetrieveRequest) (*AwsPull, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsSyncCreateRequest struct {
	ctx                      context.Context
	ApiService               *IntegrationsApiService
	awsintegrationPk         string
	id                       string
	awsPullSyncActionRequest *AwsPullSyncActionRequest
}

func (r ApiIntegrationsAwsPullsSyncCreateRequest) AwsPullSyncActionRequest(awsPullSyncActionRequest AwsPullSyncActionRequest) ApiIntegrationsAwsPullsSyncCreateRequest {
	r.awsPullSyncActionRequest = &awsPullSyncActionRequest
	return r
}

func (r ApiIntegrationsAwsPullsSyncCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationsAwsPullsSyncCreateExecute(r)
}

/*
IntegrationsAwsPullsSyncCreate Method for IntegrationsAwsPullsSyncCreate

Enqueue a pull synchronization task for mapped external values accessible with this integration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPullsSyncCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsSyncCreate(ctx context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPullsSyncCreateRequest {
	return ApiIntegrationsAwsPullsSyncCreateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAwsPullsSyncCreateExecute(r ApiIntegrationsAwsPullsSyncCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsSyncCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{id}/sync/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsPullSyncActionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsTasksListRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awspullPk        string
	modifiedAt       *time.Time
	modifiedAtGte    *time.Time
	modifiedAtLte    *time.Time
	ordering         *string
	page             *int32
	pageSize         *int32
	state            *string
}

func (r ApiIntegrationsAwsPullsTasksListRequest) ModifiedAt(modifiedAt time.Time) ApiIntegrationsAwsPullsTasksListRequest {
	r.modifiedAt = &modifiedAt
	return r
}

func (r ApiIntegrationsAwsPullsTasksListRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiIntegrationsAwsPullsTasksListRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}

func (r ApiIntegrationsAwsPullsTasksListRequest) ModifiedAtLte(modifiedAtLte time.Time) ApiIntegrationsAwsPullsTasksListRequest {
	r.modifiedAtLte = &modifiedAtLte
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAwsPullsTasksListRequest) Ordering(ordering string) ApiIntegrationsAwsPullsTasksListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAwsPullsTasksListRequest) Page(page int32) ApiIntegrationsAwsPullsTasksListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAwsPullsTasksListRequest) PageSize(pageSize int32) ApiIntegrationsAwsPullsTasksListRequest {
	r.pageSize = &pageSize
	return r
}

// The current state of this task.
func (r ApiIntegrationsAwsPullsTasksListRequest) State(state string) ApiIntegrationsAwsPullsTasksListRequest {
	r.state = &state
	return r
}

func (r ApiIntegrationsAwsPullsTasksListRequest) Execute() (*PaginatedAwsPullTaskList, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPullsTasksListExecute(r)
}

/*
IntegrationsAwsPullsTasksList Method for IntegrationsAwsPullsTasksList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspullPk
 @return ApiIntegrationsAwsPullsTasksListRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksList(ctx context.Context, awsintegrationPk string, awspullPk string) ApiIntegrationsAwsPullsTasksListRequest {
	return ApiIntegrationsAwsPullsTasksListRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspullPk:        awspullPk,
	}
}

// Execute executes the request
//  @return PaginatedAwsPullTaskList
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksListExecute(r ApiIntegrationsAwsPullsTasksListRequest) (*PaginatedAwsPullTaskList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAwsPullTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsTasksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{awspull_pk}/tasks/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspull_pk"+"}", url.PathEscape(parameterToString(r.awspullPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.modifiedAt != nil {
		localVarQueryParams.Add("modified_at", parameterToString(*r.modifiedAt, ""))
	}
	if r.modifiedAtGte != nil {
		localVarQueryParams.Add("modified_at__gte", parameterToString(*r.modifiedAtGte, ""))
	}
	if r.modifiedAtLte != nil {
		localVarQueryParams.Add("modified_at__lte", parameterToString(*r.modifiedAtLte, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsTasksRetrieveRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awspullPk        string
	id               string
}

func (r ApiIntegrationsAwsPullsTasksRetrieveRequest) Execute() (*AwsPullTask, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPullsTasksRetrieveExecute(r)
}

/*
IntegrationsAwsPullsTasksRetrieve Method for IntegrationsAwsPullsTasksRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspullPk
 @param id
 @return ApiIntegrationsAwsPullsTasksRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksRetrieve(ctx context.Context, awsintegrationPk string, awspullPk string, id string) ApiIntegrationsAwsPullsTasksRetrieveRequest {
	return ApiIntegrationsAwsPullsTasksRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspullPk:        awspullPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPullTask
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksRetrieveExecute(r ApiIntegrationsAwsPullsTasksRetrieveRequest) (*AwsPullTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsPullTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsTasksRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{awspull_pk}/tasks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspull_pk"+"}", url.PathEscape(parameterToString(r.awspullPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsTasksStepsListRequest struct {
	ctx                context.Context
	ApiService         *IntegrationsApiService
	awsintegrationPk   string
	awspullPk          string
	awspulltaskPk      string
	fqn                *string
	modifiedAt         *time.Time
	modifiedAtGte      *time.Time
	modifiedAtLte      *time.Time
	operation          *string
	ordering           *string
	page               *int32
	pageSize           *int32
	success            *bool
	venueId            *string
	venueIdIcontains   *string
	venueName          *string
	venueNameIcontains *string
}

func (r ApiIntegrationsAwsPullsTasksStepsListRequest) Fqn(fqn string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.fqn = &fqn
	return r
}

func (r ApiIntegrationsAwsPullsTasksStepsListRequest) ModifiedAt(modifiedAt time.Time) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.modifiedAt = &modifiedAt
	return r
}

func (r ApiIntegrationsAwsPullsTasksStepsListRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}

func (r ApiIntegrationsAwsPullsTasksStepsListRequest) ModifiedAtLte(modifiedAtLte time.Time) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.modifiedAtLte = &modifiedAtLte
	return r
}

// The operation performed, if any.  When the operation is an update, there may be additional details in the success_detail field to describe the change.  When the project is filled in but the environment and parameterare not, the operation is on the project.  When the environmentis filled in but the project and parameter are not, the operationis on the environment.  When the project and parameter are filledin but the environment is not, the operation is on the parameter.When all three are filled in, the operation is on the value ofthe parameter of the project in the specified environment.
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) Operation(operation string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.operation = &operation
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) Ordering(ordering string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) Page(page int32) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAwsPullsTasksStepsListRequest) PageSize(pageSize int32) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsAwsPullsTasksStepsListRequest) Success(success bool) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.success = &success
	return r
}

func (r ApiIntegrationsAwsPullsTasksStepsListRequest) VenueId(venueId string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.venueId = &venueId
	return r
}

func (r ApiIntegrationsAwsPullsTasksStepsListRequest) VenueIdIcontains(venueIdIcontains string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.venueIdIcontains = &venueIdIcontains
	return r
}

func (r ApiIntegrationsAwsPullsTasksStepsListRequest) VenueName(venueName string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.venueName = &venueName
	return r
}

func (r ApiIntegrationsAwsPullsTasksStepsListRequest) VenueNameIcontains(venueNameIcontains string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	r.venueNameIcontains = &venueNameIcontains
	return r
}

func (r ApiIntegrationsAwsPullsTasksStepsListRequest) Execute() (*PaginatedAwsPullTaskStepList, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPullsTasksStepsListExecute(r)
}

/*
IntegrationsAwsPullsTasksStepsList Method for IntegrationsAwsPullsTasksStepsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspullPk
 @param awspulltaskPk
 @return ApiIntegrationsAwsPullsTasksStepsListRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksStepsList(ctx context.Context, awsintegrationPk string, awspullPk string, awspulltaskPk string) ApiIntegrationsAwsPullsTasksStepsListRequest {
	return ApiIntegrationsAwsPullsTasksStepsListRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspullPk:        awspullPk,
		awspulltaskPk:    awspulltaskPk,
	}
}

// Execute executes the request
//  @return PaginatedAwsPullTaskStepList
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksStepsListExecute(r ApiIntegrationsAwsPullsTasksStepsListRequest) (*PaginatedAwsPullTaskStepList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAwsPullTaskStepList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsTasksStepsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{awspull_pk}/tasks/{awspulltask_pk}/steps/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspull_pk"+"}", url.PathEscape(parameterToString(r.awspullPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspulltask_pk"+"}", url.PathEscape(parameterToString(r.awspulltaskPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fqn != nil {
		localVarQueryParams.Add("fqn", parameterToString(*r.fqn, ""))
	}
	if r.modifiedAt != nil {
		localVarQueryParams.Add("modified_at", parameterToString(*r.modifiedAt, ""))
	}
	if r.modifiedAtGte != nil {
		localVarQueryParams.Add("modified_at__gte", parameterToString(*r.modifiedAtGte, ""))
	}
	if r.modifiedAtLte != nil {
		localVarQueryParams.Add("modified_at__lte", parameterToString(*r.modifiedAtLte, ""))
	}
	if r.operation != nil {
		localVarQueryParams.Add("operation", parameterToString(*r.operation, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.success != nil {
		localVarQueryParams.Add("success", parameterToString(*r.success, ""))
	}
	if r.venueId != nil {
		localVarQueryParams.Add("venue_id", parameterToString(*r.venueId, ""))
	}
	if r.venueIdIcontains != nil {
		localVarQueryParams.Add("venue_id__icontains", parameterToString(*r.venueIdIcontains, ""))
	}
	if r.venueName != nil {
		localVarQueryParams.Add("venue_name", parameterToString(*r.venueName, ""))
	}
	if r.venueNameIcontains != nil {
		localVarQueryParams.Add("venue_name__icontains", parameterToString(*r.venueNameIcontains, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsTasksStepsRetrieveRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awspullPk        string
	awspulltaskPk    string
	id               string
}

func (r ApiIntegrationsAwsPullsTasksStepsRetrieveRequest) Execute() (*AwsPullTaskStep, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPullsTasksStepsRetrieveExecute(r)
}

/*
IntegrationsAwsPullsTasksStepsRetrieve Method for IntegrationsAwsPullsTasksStepsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspullPk
 @param awspulltaskPk
 @param id
 @return ApiIntegrationsAwsPullsTasksStepsRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksStepsRetrieve(ctx context.Context, awsintegrationPk string, awspullPk string, awspulltaskPk string, id string) ApiIntegrationsAwsPullsTasksStepsRetrieveRequest {
	return ApiIntegrationsAwsPullsTasksStepsRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspullPk:        awspullPk,
		awspulltaskPk:    awspulltaskPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPullTaskStep
func (a *IntegrationsApiService) IntegrationsAwsPullsTasksStepsRetrieveExecute(r ApiIntegrationsAwsPullsTasksStepsRetrieveRequest) (*AwsPullTaskStep, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsPullTaskStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsTasksStepsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{awspull_pk}/tasks/{awspulltask_pk}/steps/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspull_pk"+"}", url.PathEscape(parameterToString(r.awspullPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspulltask_pk"+"}", url.PathEscape(parameterToString(r.awspulltaskPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPullsUpdateRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
	awsPull          *AwsPull
}

func (r ApiIntegrationsAwsPullsUpdateRequest) AwsPull(awsPull AwsPull) ApiIntegrationsAwsPullsUpdateRequest {
	r.awsPull = &awsPull
	return r
}

func (r ApiIntegrationsAwsPullsUpdateRequest) Execute() (*AwsPull, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPullsUpdateExecute(r)
}

/*
IntegrationsAwsPullsUpdate Method for IntegrationsAwsPullsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPullsUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPullsUpdate(ctx context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPullsUpdateRequest {
	return ApiIntegrationsAwsPullsUpdateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPull
func (a *IntegrationsApiService) IntegrationsAwsPullsUpdateExecute(r ApiIntegrationsAwsPullsUpdateRequest) (*AwsPull, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPullsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.awsPull == nil {
		return localVarReturnValue, nil, reportError("awsPull is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsPull
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesCreateRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awsPush          *AwsPush
}

func (r ApiIntegrationsAwsPushesCreateRequest) AwsPush(awsPush AwsPush) ApiIntegrationsAwsPushesCreateRequest {
	r.awsPush = &awsPush
	return r
}

func (r ApiIntegrationsAwsPushesCreateRequest) Execute() (*AwsPush, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPushesCreateExecute(r)
}

/*
IntegrationsAwsPushesCreate Method for IntegrationsAwsPushesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @return ApiIntegrationsAwsPushesCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesCreate(ctx context.Context, awsintegrationPk string) ApiIntegrationsAwsPushesCreateRequest {
	return ApiIntegrationsAwsPushesCreateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
	}
}

// Execute executes the request
//  @return AwsPush
func (a *IntegrationsApiService) IntegrationsAwsPushesCreateExecute(r ApiIntegrationsAwsPushesCreateRequest) (*AwsPush, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsPush
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.awsPush == nil {
		return localVarReturnValue, nil, reportError("awsPush is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsPush
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesDestroyRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
}

func (r ApiIntegrationsAwsPushesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationsAwsPushesDestroyExecute(r)
}

/*
IntegrationsAwsPushesDestroy Method for IntegrationsAwsPushesDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPushesDestroyRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesDestroy(ctx context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPushesDestroyRequest {
	return ApiIntegrationsAwsPushesDestroyRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAwsPushesDestroyExecute(r ApiIntegrationsAwsPushesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesListRequest struct {
	ctx                  context.Context
	ApiService           *IntegrationsApiService
	awsintegrationPk     string
	descriptionIcontains *string
	environment          *string
	name                 *string
	nameIcontains        *string
	ordering             *string
	page                 *int32
	pageSize             *int32
	project              *string
	tag                  *string
}

func (r ApiIntegrationsAwsPushesListRequest) DescriptionIcontains(descriptionIcontains string) ApiIntegrationsAwsPushesListRequest {
	r.descriptionIcontains = &descriptionIcontains
	return r
}

// Filter results to pushes that operate on a tag in the given environment.
func (r ApiIntegrationsAwsPushesListRequest) Environment(environment string) ApiIntegrationsAwsPushesListRequest {
	r.environment = &environment
	return r
}

func (r ApiIntegrationsAwsPushesListRequest) Name(name string) ApiIntegrationsAwsPushesListRequest {
	r.name = &name
	return r
}

func (r ApiIntegrationsAwsPushesListRequest) NameIcontains(nameIcontains string) ApiIntegrationsAwsPushesListRequest {
	r.nameIcontains = &nameIcontains
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAwsPushesListRequest) Ordering(ordering string) ApiIntegrationsAwsPushesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAwsPushesListRequest) Page(page int32) ApiIntegrationsAwsPushesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAwsPushesListRequest) PageSize(pageSize int32) ApiIntegrationsAwsPushesListRequest {
	r.pageSize = &pageSize
	return r
}

// Filter results to pushes that operate on the given project.
func (r ApiIntegrationsAwsPushesListRequest) Project(project string) ApiIntegrationsAwsPushesListRequest {
	r.project = &project
	return r
}

// Filter results to pushes that operate on the given tag.
func (r ApiIntegrationsAwsPushesListRequest) Tag(tag string) ApiIntegrationsAwsPushesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIntegrationsAwsPushesListRequest) Execute() (*PaginatedAwsPushList, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPushesListExecute(r)
}

/*
IntegrationsAwsPushesList Method for IntegrationsAwsPushesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @return ApiIntegrationsAwsPushesListRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesList(ctx context.Context, awsintegrationPk string) ApiIntegrationsAwsPushesListRequest {
	return ApiIntegrationsAwsPushesListRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
	}
}

// Execute executes the request
//  @return PaginatedAwsPushList
func (a *IntegrationsApiService) IntegrationsAwsPushesListExecute(r ApiIntegrationsAwsPushesListRequest) (*PaginatedAwsPushList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAwsPushList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.descriptionIcontains != nil {
		localVarQueryParams.Add("description__icontains", parameterToString(*r.descriptionIcontains, ""))
	}
	if r.environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.environment, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameIcontains != nil {
		localVarQueryParams.Add("name__icontains", parameterToString(*r.nameIcontains, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.project != nil {
		localVarQueryParams.Add("project", parameterToString(*r.project, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesPartialUpdateRequest struct {
	ctx                  context.Context
	ApiService           *IntegrationsApiService
	awsintegrationPk     string
	id                   string
	patchedAwsPushUpdate *PatchedAwsPushUpdate
}

func (r ApiIntegrationsAwsPushesPartialUpdateRequest) PatchedAwsPushUpdate(patchedAwsPushUpdate PatchedAwsPushUpdate) ApiIntegrationsAwsPushesPartialUpdateRequest {
	r.patchedAwsPushUpdate = &patchedAwsPushUpdate
	return r
}

func (r ApiIntegrationsAwsPushesPartialUpdateRequest) Execute() (*AwsPushUpdate, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPushesPartialUpdateExecute(r)
}

/*
IntegrationsAwsPushesPartialUpdate Method for IntegrationsAwsPushesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPushesPartialUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesPartialUpdate(ctx context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPushesPartialUpdateRequest {
	return ApiIntegrationsAwsPushesPartialUpdateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPushUpdate
func (a *IntegrationsApiService) IntegrationsAwsPushesPartialUpdateExecute(r ApiIntegrationsAwsPushesPartialUpdateRequest) (*AwsPushUpdate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsPushUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAwsPushUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesRetrieveRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
}

func (r ApiIntegrationsAwsPushesRetrieveRequest) Execute() (*AwsPush, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPushesRetrieveExecute(r)
}

/*
IntegrationsAwsPushesRetrieve Method for IntegrationsAwsPushesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPushesRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesRetrieve(ctx context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPushesRetrieveRequest {
	return ApiIntegrationsAwsPushesRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPush
func (a *IntegrationsApiService) IntegrationsAwsPushesRetrieveExecute(r ApiIntegrationsAwsPushesRetrieveRequest) (*AwsPush, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsPush
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesSyncCreateRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
	awsPush          *AwsPush
}

func (r ApiIntegrationsAwsPushesSyncCreateRequest) AwsPush(awsPush AwsPush) ApiIntegrationsAwsPushesSyncCreateRequest {
	r.awsPush = &awsPush
	return r
}

func (r ApiIntegrationsAwsPushesSyncCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationsAwsPushesSyncCreateExecute(r)
}

/*
IntegrationsAwsPushesSyncCreate Method for IntegrationsAwsPushesSyncCreate

Enqueue a push synchronization task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPushesSyncCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesSyncCreate(ctx context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPushesSyncCreateRequest {
	return ApiIntegrationsAwsPushesSyncCreateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAwsPushesSyncCreateExecute(r ApiIntegrationsAwsPushesSyncCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesSyncCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{id}/sync/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.awsPush == nil {
		return nil, reportError("awsPush is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsPush
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesTasksListRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awspushPk        string
	modifiedAt       *time.Time
	modifiedAtGte    *time.Time
	modifiedAtLte    *time.Time
	ordering         *string
	page             *int32
	pageSize         *int32
	state            *string
}

func (r ApiIntegrationsAwsPushesTasksListRequest) ModifiedAt(modifiedAt time.Time) ApiIntegrationsAwsPushesTasksListRequest {
	r.modifiedAt = &modifiedAt
	return r
}

func (r ApiIntegrationsAwsPushesTasksListRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiIntegrationsAwsPushesTasksListRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}

func (r ApiIntegrationsAwsPushesTasksListRequest) ModifiedAtLte(modifiedAtLte time.Time) ApiIntegrationsAwsPushesTasksListRequest {
	r.modifiedAtLte = &modifiedAtLte
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAwsPushesTasksListRequest) Ordering(ordering string) ApiIntegrationsAwsPushesTasksListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAwsPushesTasksListRequest) Page(page int32) ApiIntegrationsAwsPushesTasksListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAwsPushesTasksListRequest) PageSize(pageSize int32) ApiIntegrationsAwsPushesTasksListRequest {
	r.pageSize = &pageSize
	return r
}

// The current state of this task.
func (r ApiIntegrationsAwsPushesTasksListRequest) State(state string) ApiIntegrationsAwsPushesTasksListRequest {
	r.state = &state
	return r
}

func (r ApiIntegrationsAwsPushesTasksListRequest) Execute() (*PaginatedAwsPushTaskList, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPushesTasksListExecute(r)
}

/*
IntegrationsAwsPushesTasksList Method for IntegrationsAwsPushesTasksList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspushPk
 @return ApiIntegrationsAwsPushesTasksListRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksList(ctx context.Context, awsintegrationPk string, awspushPk string) ApiIntegrationsAwsPushesTasksListRequest {
	return ApiIntegrationsAwsPushesTasksListRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspushPk:        awspushPk,
	}
}

// Execute executes the request
//  @return PaginatedAwsPushTaskList
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksListExecute(r ApiIntegrationsAwsPushesTasksListRequest) (*PaginatedAwsPushTaskList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAwsPushTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesTasksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{awspush_pk}/tasks/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspush_pk"+"}", url.PathEscape(parameterToString(r.awspushPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.modifiedAt != nil {
		localVarQueryParams.Add("modified_at", parameterToString(*r.modifiedAt, ""))
	}
	if r.modifiedAtGte != nil {
		localVarQueryParams.Add("modified_at__gte", parameterToString(*r.modifiedAtGte, ""))
	}
	if r.modifiedAtLte != nil {
		localVarQueryParams.Add("modified_at__lte", parameterToString(*r.modifiedAtLte, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesTasksRetrieveRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awspushPk        string
	id               string
}

func (r ApiIntegrationsAwsPushesTasksRetrieveRequest) Execute() (*AwsPushTask, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPushesTasksRetrieveExecute(r)
}

/*
IntegrationsAwsPushesTasksRetrieve Method for IntegrationsAwsPushesTasksRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspushPk
 @param id
 @return ApiIntegrationsAwsPushesTasksRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksRetrieve(ctx context.Context, awsintegrationPk string, awspushPk string, id string) ApiIntegrationsAwsPushesTasksRetrieveRequest {
	return ApiIntegrationsAwsPushesTasksRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspushPk:        awspushPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPushTask
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksRetrieveExecute(r ApiIntegrationsAwsPushesTasksRetrieveRequest) (*AwsPushTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsPushTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesTasksRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{awspush_pk}/tasks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspush_pk"+"}", url.PathEscape(parameterToString(r.awspushPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesTasksStepsListRequest struct {
	ctx                context.Context
	ApiService         *IntegrationsApiService
	awsintegrationPk   string
	awspushPk          string
	awspushtaskPk      string
	fqn                *string
	modifiedAt         *time.Time
	modifiedAtGte      *time.Time
	modifiedAtLte      *time.Time
	operation          *string
	ordering           *string
	page               *int32
	pageSize           *int32
	success            *bool
	venueId            *string
	venueIdIcontains   *string
	venueName          *string
	venueNameIcontains *string
}

func (r ApiIntegrationsAwsPushesTasksStepsListRequest) Fqn(fqn string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.fqn = &fqn
	return r
}

func (r ApiIntegrationsAwsPushesTasksStepsListRequest) ModifiedAt(modifiedAt time.Time) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.modifiedAt = &modifiedAt
	return r
}

func (r ApiIntegrationsAwsPushesTasksStepsListRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}

func (r ApiIntegrationsAwsPushesTasksStepsListRequest) ModifiedAtLte(modifiedAtLte time.Time) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.modifiedAtLte = &modifiedAtLte
	return r
}

// The operation performed, if any.  When the operation is an update, there may be additional details in the success_detail field to describe the change.  When the project is filled in but the environment and parameterare not, the operation is on the project.  When the environmentis filled in but the project and parameter are not, the operationis on the environment.  When the project and parameter are filledin but the environment is not, the operation is on the parameter.When all three are filled in, the operation is on the value ofthe parameter of the project in the specified environment.
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) Operation(operation string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.operation = &operation
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) Ordering(ordering string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) Page(page int32) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAwsPushesTasksStepsListRequest) PageSize(pageSize int32) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsAwsPushesTasksStepsListRequest) Success(success bool) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.success = &success
	return r
}

func (r ApiIntegrationsAwsPushesTasksStepsListRequest) VenueId(venueId string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.venueId = &venueId
	return r
}

func (r ApiIntegrationsAwsPushesTasksStepsListRequest) VenueIdIcontains(venueIdIcontains string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.venueIdIcontains = &venueIdIcontains
	return r
}

func (r ApiIntegrationsAwsPushesTasksStepsListRequest) VenueName(venueName string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.venueName = &venueName
	return r
}

func (r ApiIntegrationsAwsPushesTasksStepsListRequest) VenueNameIcontains(venueNameIcontains string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	r.venueNameIcontains = &venueNameIcontains
	return r
}

func (r ApiIntegrationsAwsPushesTasksStepsListRequest) Execute() (*PaginatedAwsPushTaskStepList, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPushesTasksStepsListExecute(r)
}

/*
IntegrationsAwsPushesTasksStepsList Method for IntegrationsAwsPushesTasksStepsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspushPk
 @param awspushtaskPk
 @return ApiIntegrationsAwsPushesTasksStepsListRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksStepsList(ctx context.Context, awsintegrationPk string, awspushPk string, awspushtaskPk string) ApiIntegrationsAwsPushesTasksStepsListRequest {
	return ApiIntegrationsAwsPushesTasksStepsListRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspushPk:        awspushPk,
		awspushtaskPk:    awspushtaskPk,
	}
}

// Execute executes the request
//  @return PaginatedAwsPushTaskStepList
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksStepsListExecute(r ApiIntegrationsAwsPushesTasksStepsListRequest) (*PaginatedAwsPushTaskStepList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAwsPushTaskStepList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesTasksStepsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{awspush_pk}/tasks/{awspushtask_pk}/steps/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspush_pk"+"}", url.PathEscape(parameterToString(r.awspushPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspushtask_pk"+"}", url.PathEscape(parameterToString(r.awspushtaskPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fqn != nil {
		localVarQueryParams.Add("fqn", parameterToString(*r.fqn, ""))
	}
	if r.modifiedAt != nil {
		localVarQueryParams.Add("modified_at", parameterToString(*r.modifiedAt, ""))
	}
	if r.modifiedAtGte != nil {
		localVarQueryParams.Add("modified_at__gte", parameterToString(*r.modifiedAtGte, ""))
	}
	if r.modifiedAtLte != nil {
		localVarQueryParams.Add("modified_at__lte", parameterToString(*r.modifiedAtLte, ""))
	}
	if r.operation != nil {
		localVarQueryParams.Add("operation", parameterToString(*r.operation, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.success != nil {
		localVarQueryParams.Add("success", parameterToString(*r.success, ""))
	}
	if r.venueId != nil {
		localVarQueryParams.Add("venue_id", parameterToString(*r.venueId, ""))
	}
	if r.venueIdIcontains != nil {
		localVarQueryParams.Add("venue_id__icontains", parameterToString(*r.venueIdIcontains, ""))
	}
	if r.venueName != nil {
		localVarQueryParams.Add("venue_name", parameterToString(*r.venueName, ""))
	}
	if r.venueNameIcontains != nil {
		localVarQueryParams.Add("venue_name__icontains", parameterToString(*r.venueNameIcontains, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesTasksStepsRetrieveRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	awspushPk        string
	awspushtaskPk    string
	id               string
}

func (r ApiIntegrationsAwsPushesTasksStepsRetrieveRequest) Execute() (*AwsPushTaskStep, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPushesTasksStepsRetrieveExecute(r)
}

/*
IntegrationsAwsPushesTasksStepsRetrieve Method for IntegrationsAwsPushesTasksStepsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param awspushPk
 @param awspushtaskPk
 @param id
 @return ApiIntegrationsAwsPushesTasksStepsRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksStepsRetrieve(ctx context.Context, awsintegrationPk string, awspushPk string, awspushtaskPk string, id string) ApiIntegrationsAwsPushesTasksStepsRetrieveRequest {
	return ApiIntegrationsAwsPushesTasksStepsRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		awspushPk:        awspushPk,
		awspushtaskPk:    awspushtaskPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPushTaskStep
func (a *IntegrationsApiService) IntegrationsAwsPushesTasksStepsRetrieveExecute(r ApiIntegrationsAwsPushesTasksStepsRetrieveRequest) (*AwsPushTaskStep, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsPushTaskStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesTasksStepsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{awspush_pk}/tasks/{awspushtask_pk}/steps/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspush_pk"+"}", url.PathEscape(parameterToString(r.awspushPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"awspushtask_pk"+"}", url.PathEscape(parameterToString(r.awspushtaskPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsPushesUpdateRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	awsintegrationPk string
	id               string
	awsPushUpdate    *AwsPushUpdate
}

func (r ApiIntegrationsAwsPushesUpdateRequest) AwsPushUpdate(awsPushUpdate AwsPushUpdate) ApiIntegrationsAwsPushesUpdateRequest {
	r.awsPushUpdate = &awsPushUpdate
	return r
}

func (r ApiIntegrationsAwsPushesUpdateRequest) Execute() (*AwsPushUpdate, *http.Response, error) {
	return r.ApiService.IntegrationsAwsPushesUpdateExecute(r)
}

/*
IntegrationsAwsPushesUpdate Method for IntegrationsAwsPushesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param awsintegrationPk
 @param id
 @return ApiIntegrationsAwsPushesUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsPushesUpdate(ctx context.Context, awsintegrationPk string, id string) ApiIntegrationsAwsPushesUpdateRequest {
	return ApiIntegrationsAwsPushesUpdateRequest{
		ApiService:       a,
		ctx:              ctx,
		awsintegrationPk: awsintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AwsPushUpdate
func (a *IntegrationsApiService) IntegrationsAwsPushesUpdateExecute(r ApiIntegrationsAwsPushesUpdateRequest) (*AwsPushUpdate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsPushUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsPushesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{awsintegration_pk}/pushes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"awsintegration_pk"+"}", url.PathEscape(parameterToString(r.awsintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.awsPushUpdate == nil {
		return localVarReturnValue, nil, reportError("awsPushUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsPushUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsRetrieveRequest struct {
	ctx           context.Context
	ApiService    *IntegrationsApiService
	id            string
	refreshStatus *bool
}

// Trigger a refresh of the integration status before returning the details.
func (r ApiIntegrationsAwsRetrieveRequest) RefreshStatus(refreshStatus bool) ApiIntegrationsAwsRetrieveRequest {
	r.refreshStatus = &refreshStatus
	return r
}

func (r ApiIntegrationsAwsRetrieveRequest) Execute() (*AwsIntegration, *http.Response, error) {
	return r.ApiService.IntegrationsAwsRetrieveExecute(r)
}

/*
IntegrationsAwsRetrieve Get details of an AWS Integration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsAwsRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsRetrieve(ctx context.Context, id string) ApiIntegrationsAwsRetrieveRequest {
	return ApiIntegrationsAwsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return AwsIntegration
func (a *IntegrationsApiService) IntegrationsAwsRetrieveExecute(r ApiIntegrationsAwsRetrieveRequest) (*AwsIntegration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.refreshStatus != nil {
		localVarQueryParams.Add("refresh_status", parameterToString(*r.refreshStatus, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsScanCreateRequest struct {
	ctx                context.Context
	ApiService         *IntegrationsApiService
	id                 string
	awsIntegrationScan *AwsIntegrationScan
}

func (r ApiIntegrationsAwsScanCreateRequest) AwsIntegrationScan(awsIntegrationScan AwsIntegrationScan) ApiIntegrationsAwsScanCreateRequest {
	r.awsIntegrationScan = &awsIntegrationScan
	return r
}

func (r ApiIntegrationsAwsScanCreateRequest) Execute() (*DiscoveryResult, *http.Response, error) {
	return r.ApiService.IntegrationsAwsScanCreateExecute(r)
}

/*
IntegrationsAwsScanCreate Evaluate a potential pull pattern and understand what it will match.

Probe a region and service using a pattern matching string that can be used in pull actions.  This allows the pattern match to be checked for correctness and preview what will match during creation of the string.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsAwsScanCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsScanCreate(ctx context.Context, id string) ApiIntegrationsAwsScanCreateRequest {
	return ApiIntegrationsAwsScanCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return DiscoveryResult
func (a *IntegrationsApiService) IntegrationsAwsScanCreateExecute(r ApiIntegrationsAwsScanCreateRequest) (*DiscoveryResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DiscoveryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsScanCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{id}/scan/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.awsIntegrationScan == nil {
		return localVarReturnValue, nil, reportError("awsIntegrationScan is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsIntegrationScan
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAwsUpdateRequest struct {
	ctx            context.Context
	ApiService     *IntegrationsApiService
	id             string
	awsIntegration *AwsIntegration
}

func (r ApiIntegrationsAwsUpdateRequest) AwsIntegration(awsIntegration AwsIntegration) ApiIntegrationsAwsUpdateRequest {
	r.awsIntegration = &awsIntegration
	return r
}

func (r ApiIntegrationsAwsUpdateRequest) Execute() (*AwsIntegration, *http.Response, error) {
	return r.ApiService.IntegrationsAwsUpdateExecute(r)
}

/*
IntegrationsAwsUpdate Method for IntegrationsAwsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsAwsUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAwsUpdate(ctx context.Context, id string) ApiIntegrationsAwsUpdateRequest {
	return ApiIntegrationsAwsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return AwsIntegration
func (a *IntegrationsApiService) IntegrationsAwsUpdateExecute(r ApiIntegrationsAwsUpdateRequest) (*AwsIntegration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AwsIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAwsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/aws/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.awsIntegration == nil {
		return localVarReturnValue, nil, reportError("awsIntegration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.awsIntegration
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultCreateRequest struct {
	ctx                            context.Context
	ApiService                     *IntegrationsApiService
	azureKeyVaultIntegrationCreate *AzureKeyVaultIntegrationCreate
}

func (r ApiIntegrationsAzureKeyVaultCreateRequest) AzureKeyVaultIntegrationCreate(azureKeyVaultIntegrationCreate AzureKeyVaultIntegrationCreate) ApiIntegrationsAzureKeyVaultCreateRequest {
	r.azureKeyVaultIntegrationCreate = &azureKeyVaultIntegrationCreate
	return r
}

func (r ApiIntegrationsAzureKeyVaultCreateRequest) Execute() (*AzureKeyVaultIntegration, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultCreateExecute(r)
}

/*
IntegrationsAzureKeyVaultCreate Establishes an Azure Key Vault Integration.

### Description ###

Establishes an Azure Key Vault Integration for your CloudTruth organization.

### Pre-Conditions ###

- An OAuth2 request to install the CloudTruth application in your Azure Tenant must acquire your consent.  The resulting JWT access key will contain a `tid` claim that is your Tenant ID.  Use this Tenant ID to set up your integration.

### Post-Conditions ###

- You must then grant the CloudTruth service principal rights to access the key  vault as a Secrets Manager role (read and write access - purge is not required).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntegrationsAzureKeyVaultCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultCreate(ctx context.Context) ApiIntegrationsAzureKeyVaultCreateRequest {
	return ApiIntegrationsAzureKeyVaultCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return AzureKeyVaultIntegration
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultCreateExecute(r ApiIntegrationsAzureKeyVaultCreateRequest) (*AzureKeyVaultIntegration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.azureKeyVaultIntegrationCreate == nil {
		return localVarReturnValue, nil, reportError("azureKeyVaultIntegrationCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.azureKeyVaultIntegrationCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultDestroyRequest struct {
	ctx        context.Context
	ApiService *IntegrationsApiService
	id         string
	inUse      *string
}

// (Optional) Desired behavior if the integration has in-use values.  - &#x60;fail&#x60; will return HTTP error 409 if there are any values using the integration. - &#x60;leave&#x60; (default) will leave values in place and future queries may fail; you can control future value query behavior with the &#x60;lookup_error&#x60; query parameter on those requests. - &#x60;remove&#x60; will remove the all values using the integration when the integration is removed.
func (r ApiIntegrationsAzureKeyVaultDestroyRequest) InUse(inUse string) ApiIntegrationsAzureKeyVaultDestroyRequest {
	r.inUse = &inUse
	return r
}

func (r ApiIntegrationsAzureKeyVaultDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultDestroyExecute(r)
}

/*
IntegrationsAzureKeyVaultDestroy Delete an AWS integration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsAzureKeyVaultDestroyRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultDestroy(ctx context.Context, id string) ApiIntegrationsAzureKeyVaultDestroyRequest {
	return ApiIntegrationsAzureKeyVaultDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultDestroyExecute(r ApiIntegrationsAzureKeyVaultDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inUse != nil {
		localVarQueryParams.Add("in_use", parameterToString(*r.inUse, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultListRequest struct {
	ctx        context.Context
	ApiService *IntegrationsApiService
	ordering   *string
	page       *int32
	pageSize   *int32
	tenantId   *string
	vaultName  *string
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAzureKeyVaultListRequest) Ordering(ordering string) ApiIntegrationsAzureKeyVaultListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAzureKeyVaultListRequest) Page(page int32) ApiIntegrationsAzureKeyVaultListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAzureKeyVaultListRequest) PageSize(pageSize int32) ApiIntegrationsAzureKeyVaultListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsAzureKeyVaultListRequest) TenantId(tenantId string) ApiIntegrationsAzureKeyVaultListRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiIntegrationsAzureKeyVaultListRequest) VaultName(vaultName string) ApiIntegrationsAzureKeyVaultListRequest {
	r.vaultName = &vaultName
	return r
}

func (r ApiIntegrationsAzureKeyVaultListRequest) Execute() (*PaginatedAzureKeyVaultIntegrationList, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultListExecute(r)
}

/*
IntegrationsAzureKeyVaultList Method for IntegrationsAzureKeyVaultList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntegrationsAzureKeyVaultListRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultList(ctx context.Context) ApiIntegrationsAzureKeyVaultListRequest {
	return ApiIntegrationsAzureKeyVaultListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedAzureKeyVaultIntegrationList
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultListExecute(r ApiIntegrationsAzureKeyVaultListRequest) (*PaginatedAzureKeyVaultIntegrationList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAzureKeyVaultIntegrationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.tenantId != nil {
		localVarQueryParams.Add("tenant_id", parameterToString(*r.tenantId, ""))
	}
	if r.vaultName != nil {
		localVarQueryParams.Add("vault_name", parameterToString(*r.vaultName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPartialUpdateRequest struct {
	ctx                             context.Context
	ApiService                      *IntegrationsApiService
	id                              string
	patchedAzureKeyVaultIntegration *PatchedAzureKeyVaultIntegration
}

func (r ApiIntegrationsAzureKeyVaultPartialUpdateRequest) PatchedAzureKeyVaultIntegration(patchedAzureKeyVaultIntegration PatchedAzureKeyVaultIntegration) ApiIntegrationsAzureKeyVaultPartialUpdateRequest {
	r.patchedAzureKeyVaultIntegration = &patchedAzureKeyVaultIntegration
	return r
}

func (r ApiIntegrationsAzureKeyVaultPartialUpdateRequest) Execute() (*AzureKeyVaultIntegration, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPartialUpdateExecute(r)
}

/*
IntegrationsAzureKeyVaultPartialUpdate Method for IntegrationsAzureKeyVaultPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsAzureKeyVaultPartialUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPartialUpdate(ctx context.Context, id string) ApiIntegrationsAzureKeyVaultPartialUpdateRequest {
	return ApiIntegrationsAzureKeyVaultPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return AzureKeyVaultIntegration
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPartialUpdateExecute(r ApiIntegrationsAzureKeyVaultPartialUpdateRequest) (*AzureKeyVaultIntegration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAzureKeyVaultIntegration
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPullsCreateRequest struct {
	ctx               context.Context
	ApiService        *IntegrationsApiService
	akvintegrationPk  string
	azureKeyVaultPull *AzureKeyVaultPull
}

func (r ApiIntegrationsAzureKeyVaultPullsCreateRequest) AzureKeyVaultPull(azureKeyVaultPull AzureKeyVaultPull) ApiIntegrationsAzureKeyVaultPullsCreateRequest {
	r.azureKeyVaultPull = &azureKeyVaultPull
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsCreateRequest) Execute() (*AzureKeyVaultPull, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPullsCreateExecute(r)
}

/*
IntegrationsAzureKeyVaultPullsCreate Method for IntegrationsAzureKeyVaultPullsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @return ApiIntegrationsAzureKeyVaultPullsCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsCreate(ctx context.Context, akvintegrationPk string) ApiIntegrationsAzureKeyVaultPullsCreateRequest {
	return ApiIntegrationsAzureKeyVaultPullsCreateRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
	}
}

// Execute executes the request
//  @return AzureKeyVaultPull
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsCreateExecute(r ApiIntegrationsAzureKeyVaultPullsCreateRequest) (*AzureKeyVaultPull, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPullsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pulls/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.azureKeyVaultPull == nil {
		return localVarReturnValue, nil, reportError("azureKeyVaultPull is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.azureKeyVaultPull
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPullsDestroyRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	akvintegrationPk string
	id               string
}

func (r ApiIntegrationsAzureKeyVaultPullsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPullsDestroyExecute(r)
}

/*
IntegrationsAzureKeyVaultPullsDestroy Method for IntegrationsAzureKeyVaultPullsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param id
 @return ApiIntegrationsAzureKeyVaultPullsDestroyRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsDestroy(ctx context.Context, akvintegrationPk string, id string) ApiIntegrationsAzureKeyVaultPullsDestroyRequest {
	return ApiIntegrationsAzureKeyVaultPullsDestroyRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		id:               id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsDestroyExecute(r ApiIntegrationsAzureKeyVaultPullsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPullsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPullsListRequest struct {
	ctx                  context.Context
	ApiService           *IntegrationsApiService
	akvintegrationPk     string
	descriptionIcontains *string
	name                 *string
	nameIcontains        *string
	ordering             *string
	page                 *int32
	pageSize             *int32
}

func (r ApiIntegrationsAzureKeyVaultPullsListRequest) DescriptionIcontains(descriptionIcontains string) ApiIntegrationsAzureKeyVaultPullsListRequest {
	r.descriptionIcontains = &descriptionIcontains
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsListRequest) Name(name string) ApiIntegrationsAzureKeyVaultPullsListRequest {
	r.name = &name
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsListRequest) NameIcontains(nameIcontains string) ApiIntegrationsAzureKeyVaultPullsListRequest {
	r.nameIcontains = &nameIcontains
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAzureKeyVaultPullsListRequest) Ordering(ordering string) ApiIntegrationsAzureKeyVaultPullsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAzureKeyVaultPullsListRequest) Page(page int32) ApiIntegrationsAzureKeyVaultPullsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAzureKeyVaultPullsListRequest) PageSize(pageSize int32) ApiIntegrationsAzureKeyVaultPullsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsListRequest) Execute() (*PaginatedAzureKeyVaultPullList, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPullsListExecute(r)
}

/*
IntegrationsAzureKeyVaultPullsList Method for IntegrationsAzureKeyVaultPullsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @return ApiIntegrationsAzureKeyVaultPullsListRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsList(ctx context.Context, akvintegrationPk string) ApiIntegrationsAzureKeyVaultPullsListRequest {
	return ApiIntegrationsAzureKeyVaultPullsListRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
	}
}

// Execute executes the request
//  @return PaginatedAzureKeyVaultPullList
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsListExecute(r ApiIntegrationsAzureKeyVaultPullsListRequest) (*PaginatedAzureKeyVaultPullList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAzureKeyVaultPullList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPullsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pulls/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.descriptionIcontains != nil {
		localVarQueryParams.Add("description__icontains", parameterToString(*r.descriptionIcontains, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameIcontains != nil {
		localVarQueryParams.Add("name__icontains", parameterToString(*r.nameIcontains, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPullsPartialUpdateRequest struct {
	ctx                      context.Context
	ApiService               *IntegrationsApiService
	akvintegrationPk         string
	id                       string
	patchedAzureKeyVaultPull *PatchedAzureKeyVaultPull
}

func (r ApiIntegrationsAzureKeyVaultPullsPartialUpdateRequest) PatchedAzureKeyVaultPull(patchedAzureKeyVaultPull PatchedAzureKeyVaultPull) ApiIntegrationsAzureKeyVaultPullsPartialUpdateRequest {
	r.patchedAzureKeyVaultPull = &patchedAzureKeyVaultPull
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsPartialUpdateRequest) Execute() (*AzureKeyVaultPull, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPullsPartialUpdateExecute(r)
}

/*
IntegrationsAzureKeyVaultPullsPartialUpdate Method for IntegrationsAzureKeyVaultPullsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param id
 @return ApiIntegrationsAzureKeyVaultPullsPartialUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsPartialUpdate(ctx context.Context, akvintegrationPk string, id string) ApiIntegrationsAzureKeyVaultPullsPartialUpdateRequest {
	return ApiIntegrationsAzureKeyVaultPullsPartialUpdateRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AzureKeyVaultPull
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsPartialUpdateExecute(r ApiIntegrationsAzureKeyVaultPullsPartialUpdateRequest) (*AzureKeyVaultPull, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPullsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAzureKeyVaultPull
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPullsRetrieveRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	akvintegrationPk string
	id               string
}

func (r ApiIntegrationsAzureKeyVaultPullsRetrieveRequest) Execute() (*AzureKeyVaultPull, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPullsRetrieveExecute(r)
}

/*
IntegrationsAzureKeyVaultPullsRetrieve Method for IntegrationsAzureKeyVaultPullsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param id
 @return ApiIntegrationsAzureKeyVaultPullsRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsRetrieve(ctx context.Context, akvintegrationPk string, id string) ApiIntegrationsAzureKeyVaultPullsRetrieveRequest {
	return ApiIntegrationsAzureKeyVaultPullsRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AzureKeyVaultPull
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsRetrieveExecute(r ApiIntegrationsAzureKeyVaultPullsRetrieveRequest) (*AzureKeyVaultPull, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPullsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPullsSyncCreateRequest struct {
	ctx                                context.Context
	ApiService                         *IntegrationsApiService
	akvintegrationPk                   string
	id                                 string
	azureKeyVaultPullSyncActionRequest *AzureKeyVaultPullSyncActionRequest
}

func (r ApiIntegrationsAzureKeyVaultPullsSyncCreateRequest) AzureKeyVaultPullSyncActionRequest(azureKeyVaultPullSyncActionRequest AzureKeyVaultPullSyncActionRequest) ApiIntegrationsAzureKeyVaultPullsSyncCreateRequest {
	r.azureKeyVaultPullSyncActionRequest = &azureKeyVaultPullSyncActionRequest
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsSyncCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPullsSyncCreateExecute(r)
}

/*
IntegrationsAzureKeyVaultPullsSyncCreate Method for IntegrationsAzureKeyVaultPullsSyncCreate

Enqueue a pull synchronization task for mapped external values accessible with this integration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param id
 @return ApiIntegrationsAzureKeyVaultPullsSyncCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsSyncCreate(ctx context.Context, akvintegrationPk string, id string) ApiIntegrationsAzureKeyVaultPullsSyncCreateRequest {
	return ApiIntegrationsAzureKeyVaultPullsSyncCreateRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		id:               id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsSyncCreateExecute(r ApiIntegrationsAzureKeyVaultPullsSyncCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPullsSyncCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pulls/{id}/sync/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.azureKeyVaultPullSyncActionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPullsTasksListRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	akvintegrationPk string
	akvpullPk        string
	modifiedAt       *time.Time
	modifiedAtGte    *time.Time
	modifiedAtLte    *time.Time
	ordering         *string
	page             *int32
	pageSize         *int32
	state            *string
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksListRequest) ModifiedAt(modifiedAt time.Time) ApiIntegrationsAzureKeyVaultPullsTasksListRequest {
	r.modifiedAt = &modifiedAt
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksListRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiIntegrationsAzureKeyVaultPullsTasksListRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksListRequest) ModifiedAtLte(modifiedAtLte time.Time) ApiIntegrationsAzureKeyVaultPullsTasksListRequest {
	r.modifiedAtLte = &modifiedAtLte
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAzureKeyVaultPullsTasksListRequest) Ordering(ordering string) ApiIntegrationsAzureKeyVaultPullsTasksListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAzureKeyVaultPullsTasksListRequest) Page(page int32) ApiIntegrationsAzureKeyVaultPullsTasksListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAzureKeyVaultPullsTasksListRequest) PageSize(pageSize int32) ApiIntegrationsAzureKeyVaultPullsTasksListRequest {
	r.pageSize = &pageSize
	return r
}

// The current state of this task.
func (r ApiIntegrationsAzureKeyVaultPullsTasksListRequest) State(state string) ApiIntegrationsAzureKeyVaultPullsTasksListRequest {
	r.state = &state
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksListRequest) Execute() (*PaginatedAzureKeyVaultPullTaskList, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPullsTasksListExecute(r)
}

/*
IntegrationsAzureKeyVaultPullsTasksList Method for IntegrationsAzureKeyVaultPullsTasksList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param akvpullPk
 @return ApiIntegrationsAzureKeyVaultPullsTasksListRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsTasksList(ctx context.Context, akvintegrationPk string, akvpullPk string) ApiIntegrationsAzureKeyVaultPullsTasksListRequest {
	return ApiIntegrationsAzureKeyVaultPullsTasksListRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		akvpullPk:        akvpullPk,
	}
}

// Execute executes the request
//  @return PaginatedAzureKeyVaultPullTaskList
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsTasksListExecute(r ApiIntegrationsAzureKeyVaultPullsTasksListRequest) (*PaginatedAzureKeyVaultPullTaskList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAzureKeyVaultPullTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPullsTasksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pulls/{akvpull_pk}/tasks/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"akvpull_pk"+"}", url.PathEscape(parameterToString(r.akvpullPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.modifiedAt != nil {
		localVarQueryParams.Add("modified_at", parameterToString(*r.modifiedAt, ""))
	}
	if r.modifiedAtGte != nil {
		localVarQueryParams.Add("modified_at__gte", parameterToString(*r.modifiedAtGte, ""))
	}
	if r.modifiedAtLte != nil {
		localVarQueryParams.Add("modified_at__lte", parameterToString(*r.modifiedAtLte, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPullsTasksRetrieveRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	akvintegrationPk string
	akvpullPk        string
	id               string
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksRetrieveRequest) Execute() (*AzureKeyVaultPullTask, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPullsTasksRetrieveExecute(r)
}

/*
IntegrationsAzureKeyVaultPullsTasksRetrieve Method for IntegrationsAzureKeyVaultPullsTasksRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param akvpullPk
 @param id
 @return ApiIntegrationsAzureKeyVaultPullsTasksRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsTasksRetrieve(ctx context.Context, akvintegrationPk string, akvpullPk string, id string) ApiIntegrationsAzureKeyVaultPullsTasksRetrieveRequest {
	return ApiIntegrationsAzureKeyVaultPullsTasksRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		akvpullPk:        akvpullPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AzureKeyVaultPullTask
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsTasksRetrieveExecute(r ApiIntegrationsAzureKeyVaultPullsTasksRetrieveRequest) (*AzureKeyVaultPullTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultPullTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPullsTasksRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pulls/{akvpull_pk}/tasks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"akvpull_pk"+"}", url.PathEscape(parameterToString(r.akvpullPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest struct {
	ctx                context.Context
	ApiService         *IntegrationsApiService
	akvintegrationPk   string
	akvpullPk          string
	akvpulltaskPk      string
	fqn                *string
	modifiedAt         *time.Time
	modifiedAtGte      *time.Time
	modifiedAtLte      *time.Time
	operation          *string
	ordering           *string
	page               *int32
	pageSize           *int32
	success            *bool
	venueId            *string
	venueIdIcontains   *string
	venueName          *string
	venueNameIcontains *string
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) Fqn(fqn string) ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest {
	r.fqn = &fqn
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) ModifiedAt(modifiedAt time.Time) ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest {
	r.modifiedAt = &modifiedAt
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) ModifiedAtLte(modifiedAtLte time.Time) ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest {
	r.modifiedAtLte = &modifiedAtLte
	return r
}

// The operation performed, if any.  When the operation is an update, there may be additional details in the success_detail field to describe the change.  When the project is filled in but the environment and parameterare not, the operation is on the project.  When the environmentis filled in but the project and parameter are not, the operationis on the environment.  When the project and parameter are filledin but the environment is not, the operation is on the parameter.When all three are filled in, the operation is on the value ofthe parameter of the project in the specified environment.
func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) Operation(operation string) ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest {
	r.operation = &operation
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) Ordering(ordering string) ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) Page(page int32) ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) PageSize(pageSize int32) ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) Success(success bool) ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest {
	r.success = &success
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) VenueId(venueId string) ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest {
	r.venueId = &venueId
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) VenueIdIcontains(venueIdIcontains string) ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest {
	r.venueIdIcontains = &venueIdIcontains
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) VenueName(venueName string) ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest {
	r.venueName = &venueName
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) VenueNameIcontains(venueNameIcontains string) ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest {
	r.venueNameIcontains = &venueNameIcontains
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) Execute() (*PaginatedAzureKeyVaultPullTaskStepList, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPullsTasksStepsListExecute(r)
}

/*
IntegrationsAzureKeyVaultPullsTasksStepsList Method for IntegrationsAzureKeyVaultPullsTasksStepsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param akvpullPk
 @param akvpulltaskPk
 @return ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsTasksStepsList(ctx context.Context, akvintegrationPk string, akvpullPk string, akvpulltaskPk string) ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest {
	return ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		akvpullPk:        akvpullPk,
		akvpulltaskPk:    akvpulltaskPk,
	}
}

// Execute executes the request
//  @return PaginatedAzureKeyVaultPullTaskStepList
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsTasksStepsListExecute(r ApiIntegrationsAzureKeyVaultPullsTasksStepsListRequest) (*PaginatedAzureKeyVaultPullTaskStepList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAzureKeyVaultPullTaskStepList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPullsTasksStepsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pulls/{akvpull_pk}/tasks/{akvpulltask_pk}/steps/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"akvpull_pk"+"}", url.PathEscape(parameterToString(r.akvpullPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"akvpulltask_pk"+"}", url.PathEscape(parameterToString(r.akvpulltaskPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fqn != nil {
		localVarQueryParams.Add("fqn", parameterToString(*r.fqn, ""))
	}
	if r.modifiedAt != nil {
		localVarQueryParams.Add("modified_at", parameterToString(*r.modifiedAt, ""))
	}
	if r.modifiedAtGte != nil {
		localVarQueryParams.Add("modified_at__gte", parameterToString(*r.modifiedAtGte, ""))
	}
	if r.modifiedAtLte != nil {
		localVarQueryParams.Add("modified_at__lte", parameterToString(*r.modifiedAtLte, ""))
	}
	if r.operation != nil {
		localVarQueryParams.Add("operation", parameterToString(*r.operation, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.success != nil {
		localVarQueryParams.Add("success", parameterToString(*r.success, ""))
	}
	if r.venueId != nil {
		localVarQueryParams.Add("venue_id", parameterToString(*r.venueId, ""))
	}
	if r.venueIdIcontains != nil {
		localVarQueryParams.Add("venue_id__icontains", parameterToString(*r.venueIdIcontains, ""))
	}
	if r.venueName != nil {
		localVarQueryParams.Add("venue_name", parameterToString(*r.venueName, ""))
	}
	if r.venueNameIcontains != nil {
		localVarQueryParams.Add("venue_name__icontains", parameterToString(*r.venueNameIcontains, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPullsTasksStepsRetrieveRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	akvintegrationPk string
	akvpullPk        string
	akvpulltaskPk    string
	id               string
}

func (r ApiIntegrationsAzureKeyVaultPullsTasksStepsRetrieveRequest) Execute() (*AzureKeyVaultPullTaskStep, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPullsTasksStepsRetrieveExecute(r)
}

/*
IntegrationsAzureKeyVaultPullsTasksStepsRetrieve Method for IntegrationsAzureKeyVaultPullsTasksStepsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param akvpullPk
 @param akvpulltaskPk
 @param id
 @return ApiIntegrationsAzureKeyVaultPullsTasksStepsRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsTasksStepsRetrieve(ctx context.Context, akvintegrationPk string, akvpullPk string, akvpulltaskPk string, id string) ApiIntegrationsAzureKeyVaultPullsTasksStepsRetrieveRequest {
	return ApiIntegrationsAzureKeyVaultPullsTasksStepsRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		akvpullPk:        akvpullPk,
		akvpulltaskPk:    akvpulltaskPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AzureKeyVaultPullTaskStep
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsTasksStepsRetrieveExecute(r ApiIntegrationsAzureKeyVaultPullsTasksStepsRetrieveRequest) (*AzureKeyVaultPullTaskStep, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultPullTaskStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPullsTasksStepsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pulls/{akvpull_pk}/tasks/{akvpulltask_pk}/steps/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"akvpull_pk"+"}", url.PathEscape(parameterToString(r.akvpullPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"akvpulltask_pk"+"}", url.PathEscape(parameterToString(r.akvpulltaskPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPullsUpdateRequest struct {
	ctx               context.Context
	ApiService        *IntegrationsApiService
	akvintegrationPk  string
	id                string
	azureKeyVaultPull *AzureKeyVaultPull
}

func (r ApiIntegrationsAzureKeyVaultPullsUpdateRequest) AzureKeyVaultPull(azureKeyVaultPull AzureKeyVaultPull) ApiIntegrationsAzureKeyVaultPullsUpdateRequest {
	r.azureKeyVaultPull = &azureKeyVaultPull
	return r
}

func (r ApiIntegrationsAzureKeyVaultPullsUpdateRequest) Execute() (*AzureKeyVaultPull, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPullsUpdateExecute(r)
}

/*
IntegrationsAzureKeyVaultPullsUpdate Method for IntegrationsAzureKeyVaultPullsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param id
 @return ApiIntegrationsAzureKeyVaultPullsUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsUpdate(ctx context.Context, akvintegrationPk string, id string) ApiIntegrationsAzureKeyVaultPullsUpdateRequest {
	return ApiIntegrationsAzureKeyVaultPullsUpdateRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AzureKeyVaultPull
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPullsUpdateExecute(r ApiIntegrationsAzureKeyVaultPullsUpdateRequest) (*AzureKeyVaultPull, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPullsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.azureKeyVaultPull == nil {
		return localVarReturnValue, nil, reportError("azureKeyVaultPull is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.azureKeyVaultPull
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPushesCreateRequest struct {
	ctx               context.Context
	ApiService        *IntegrationsApiService
	akvintegrationPk  string
	azureKeyVaultPush *AzureKeyVaultPush
}

func (r ApiIntegrationsAzureKeyVaultPushesCreateRequest) AzureKeyVaultPush(azureKeyVaultPush AzureKeyVaultPush) ApiIntegrationsAzureKeyVaultPushesCreateRequest {
	r.azureKeyVaultPush = &azureKeyVaultPush
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesCreateRequest) Execute() (*AzureKeyVaultPush, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPushesCreateExecute(r)
}

/*
IntegrationsAzureKeyVaultPushesCreate Method for IntegrationsAzureKeyVaultPushesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @return ApiIntegrationsAzureKeyVaultPushesCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesCreate(ctx context.Context, akvintegrationPk string) ApiIntegrationsAzureKeyVaultPushesCreateRequest {
	return ApiIntegrationsAzureKeyVaultPushesCreateRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
	}
}

// Execute executes the request
//  @return AzureKeyVaultPush
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesCreateExecute(r ApiIntegrationsAzureKeyVaultPushesCreateRequest) (*AzureKeyVaultPush, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultPush
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPushesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pushes/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.azureKeyVaultPush == nil {
		return localVarReturnValue, nil, reportError("azureKeyVaultPush is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.azureKeyVaultPush
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPushesDestroyRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	akvintegrationPk string
	id               string
}

func (r ApiIntegrationsAzureKeyVaultPushesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPushesDestroyExecute(r)
}

/*
IntegrationsAzureKeyVaultPushesDestroy Method for IntegrationsAzureKeyVaultPushesDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param id
 @return ApiIntegrationsAzureKeyVaultPushesDestroyRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesDestroy(ctx context.Context, akvintegrationPk string, id string) ApiIntegrationsAzureKeyVaultPushesDestroyRequest {
	return ApiIntegrationsAzureKeyVaultPushesDestroyRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		id:               id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesDestroyExecute(r ApiIntegrationsAzureKeyVaultPushesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPushesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pushes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPushesListRequest struct {
	ctx                  context.Context
	ApiService           *IntegrationsApiService
	akvintegrationPk     string
	descriptionIcontains *string
	environment          *string
	name                 *string
	nameIcontains        *string
	ordering             *string
	page                 *int32
	pageSize             *int32
	project              *string
	tag                  *string
}

func (r ApiIntegrationsAzureKeyVaultPushesListRequest) DescriptionIcontains(descriptionIcontains string) ApiIntegrationsAzureKeyVaultPushesListRequest {
	r.descriptionIcontains = &descriptionIcontains
	return r
}

// Filter results to pushes that operate on a tag in the given environment.
func (r ApiIntegrationsAzureKeyVaultPushesListRequest) Environment(environment string) ApiIntegrationsAzureKeyVaultPushesListRequest {
	r.environment = &environment
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesListRequest) Name(name string) ApiIntegrationsAzureKeyVaultPushesListRequest {
	r.name = &name
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesListRequest) NameIcontains(nameIcontains string) ApiIntegrationsAzureKeyVaultPushesListRequest {
	r.nameIcontains = &nameIcontains
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAzureKeyVaultPushesListRequest) Ordering(ordering string) ApiIntegrationsAzureKeyVaultPushesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAzureKeyVaultPushesListRequest) Page(page int32) ApiIntegrationsAzureKeyVaultPushesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAzureKeyVaultPushesListRequest) PageSize(pageSize int32) ApiIntegrationsAzureKeyVaultPushesListRequest {
	r.pageSize = &pageSize
	return r
}

// Filter results to pushes that operate on the given project.
func (r ApiIntegrationsAzureKeyVaultPushesListRequest) Project(project string) ApiIntegrationsAzureKeyVaultPushesListRequest {
	r.project = &project
	return r
}

// Filter results to pushes that operate on the given tag.
func (r ApiIntegrationsAzureKeyVaultPushesListRequest) Tag(tag string) ApiIntegrationsAzureKeyVaultPushesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesListRequest) Execute() (*PaginatedAzureKeyVaultPushList, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPushesListExecute(r)
}

/*
IntegrationsAzureKeyVaultPushesList Method for IntegrationsAzureKeyVaultPushesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @return ApiIntegrationsAzureKeyVaultPushesListRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesList(ctx context.Context, akvintegrationPk string) ApiIntegrationsAzureKeyVaultPushesListRequest {
	return ApiIntegrationsAzureKeyVaultPushesListRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
	}
}

// Execute executes the request
//  @return PaginatedAzureKeyVaultPushList
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesListExecute(r ApiIntegrationsAzureKeyVaultPushesListRequest) (*PaginatedAzureKeyVaultPushList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAzureKeyVaultPushList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPushesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pushes/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.descriptionIcontains != nil {
		localVarQueryParams.Add("description__icontains", parameterToString(*r.descriptionIcontains, ""))
	}
	if r.environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.environment, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameIcontains != nil {
		localVarQueryParams.Add("name__icontains", parameterToString(*r.nameIcontains, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.project != nil {
		localVarQueryParams.Add("project", parameterToString(*r.project, ""))
	}
	if r.tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPushesPartialUpdateRequest struct {
	ctx                            context.Context
	ApiService                     *IntegrationsApiService
	akvintegrationPk               string
	id                             string
	patchedAzureKeyVaultPushUpdate *PatchedAzureKeyVaultPushUpdate
}

func (r ApiIntegrationsAzureKeyVaultPushesPartialUpdateRequest) PatchedAzureKeyVaultPushUpdate(patchedAzureKeyVaultPushUpdate PatchedAzureKeyVaultPushUpdate) ApiIntegrationsAzureKeyVaultPushesPartialUpdateRequest {
	r.patchedAzureKeyVaultPushUpdate = &patchedAzureKeyVaultPushUpdate
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesPartialUpdateRequest) Execute() (*AzureKeyVaultPushUpdate, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPushesPartialUpdateExecute(r)
}

/*
IntegrationsAzureKeyVaultPushesPartialUpdate Method for IntegrationsAzureKeyVaultPushesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param id
 @return ApiIntegrationsAzureKeyVaultPushesPartialUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesPartialUpdate(ctx context.Context, akvintegrationPk string, id string) ApiIntegrationsAzureKeyVaultPushesPartialUpdateRequest {
	return ApiIntegrationsAzureKeyVaultPushesPartialUpdateRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AzureKeyVaultPushUpdate
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesPartialUpdateExecute(r ApiIntegrationsAzureKeyVaultPushesPartialUpdateRequest) (*AzureKeyVaultPushUpdate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultPushUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPushesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pushes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAzureKeyVaultPushUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPushesRetrieveRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	akvintegrationPk string
	id               string
}

func (r ApiIntegrationsAzureKeyVaultPushesRetrieveRequest) Execute() (*AzureKeyVaultPush, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPushesRetrieveExecute(r)
}

/*
IntegrationsAzureKeyVaultPushesRetrieve Method for IntegrationsAzureKeyVaultPushesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param id
 @return ApiIntegrationsAzureKeyVaultPushesRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesRetrieve(ctx context.Context, akvintegrationPk string, id string) ApiIntegrationsAzureKeyVaultPushesRetrieveRequest {
	return ApiIntegrationsAzureKeyVaultPushesRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AzureKeyVaultPush
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesRetrieveExecute(r ApiIntegrationsAzureKeyVaultPushesRetrieveRequest) (*AzureKeyVaultPush, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultPush
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPushesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pushes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPushesSyncCreateRequest struct {
	ctx               context.Context
	ApiService        *IntegrationsApiService
	akvintegrationPk  string
	id                string
	azureKeyVaultPush *AzureKeyVaultPush
}

func (r ApiIntegrationsAzureKeyVaultPushesSyncCreateRequest) AzureKeyVaultPush(azureKeyVaultPush AzureKeyVaultPush) ApiIntegrationsAzureKeyVaultPushesSyncCreateRequest {
	r.azureKeyVaultPush = &azureKeyVaultPush
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesSyncCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPushesSyncCreateExecute(r)
}

/*
IntegrationsAzureKeyVaultPushesSyncCreate Method for IntegrationsAzureKeyVaultPushesSyncCreate

Enqueue a push synchronization task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param id
 @return ApiIntegrationsAzureKeyVaultPushesSyncCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesSyncCreate(ctx context.Context, akvintegrationPk string, id string) ApiIntegrationsAzureKeyVaultPushesSyncCreateRequest {
	return ApiIntegrationsAzureKeyVaultPushesSyncCreateRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		id:               id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesSyncCreateExecute(r ApiIntegrationsAzureKeyVaultPushesSyncCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPushesSyncCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pushes/{id}/sync/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.azureKeyVaultPush == nil {
		return nil, reportError("azureKeyVaultPush is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.azureKeyVaultPush
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPushesTasksListRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	akvintegrationPk string
	akvpushPk        string
	modifiedAt       *time.Time
	modifiedAtGte    *time.Time
	modifiedAtLte    *time.Time
	ordering         *string
	page             *int32
	pageSize         *int32
	state            *string
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksListRequest) ModifiedAt(modifiedAt time.Time) ApiIntegrationsAzureKeyVaultPushesTasksListRequest {
	r.modifiedAt = &modifiedAt
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksListRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiIntegrationsAzureKeyVaultPushesTasksListRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksListRequest) ModifiedAtLte(modifiedAtLte time.Time) ApiIntegrationsAzureKeyVaultPushesTasksListRequest {
	r.modifiedAtLte = &modifiedAtLte
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAzureKeyVaultPushesTasksListRequest) Ordering(ordering string) ApiIntegrationsAzureKeyVaultPushesTasksListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAzureKeyVaultPushesTasksListRequest) Page(page int32) ApiIntegrationsAzureKeyVaultPushesTasksListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAzureKeyVaultPushesTasksListRequest) PageSize(pageSize int32) ApiIntegrationsAzureKeyVaultPushesTasksListRequest {
	r.pageSize = &pageSize
	return r
}

// The current state of this task.
func (r ApiIntegrationsAzureKeyVaultPushesTasksListRequest) State(state string) ApiIntegrationsAzureKeyVaultPushesTasksListRequest {
	r.state = &state
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksListRequest) Execute() (*PaginatedAzureKeyVaultPushTaskList, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPushesTasksListExecute(r)
}

/*
IntegrationsAzureKeyVaultPushesTasksList Method for IntegrationsAzureKeyVaultPushesTasksList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param akvpushPk
 @return ApiIntegrationsAzureKeyVaultPushesTasksListRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesTasksList(ctx context.Context, akvintegrationPk string, akvpushPk string) ApiIntegrationsAzureKeyVaultPushesTasksListRequest {
	return ApiIntegrationsAzureKeyVaultPushesTasksListRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		akvpushPk:        akvpushPk,
	}
}

// Execute executes the request
//  @return PaginatedAzureKeyVaultPushTaskList
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesTasksListExecute(r ApiIntegrationsAzureKeyVaultPushesTasksListRequest) (*PaginatedAzureKeyVaultPushTaskList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAzureKeyVaultPushTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPushesTasksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pushes/{akvpush_pk}/tasks/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"akvpush_pk"+"}", url.PathEscape(parameterToString(r.akvpushPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.modifiedAt != nil {
		localVarQueryParams.Add("modified_at", parameterToString(*r.modifiedAt, ""))
	}
	if r.modifiedAtGte != nil {
		localVarQueryParams.Add("modified_at__gte", parameterToString(*r.modifiedAtGte, ""))
	}
	if r.modifiedAtLte != nil {
		localVarQueryParams.Add("modified_at__lte", parameterToString(*r.modifiedAtLte, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPushesTasksRetrieveRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	akvintegrationPk string
	akvpushPk        string
	id               string
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksRetrieveRequest) Execute() (*AzureKeyVaultPushTask, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPushesTasksRetrieveExecute(r)
}

/*
IntegrationsAzureKeyVaultPushesTasksRetrieve Method for IntegrationsAzureKeyVaultPushesTasksRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param akvpushPk
 @param id
 @return ApiIntegrationsAzureKeyVaultPushesTasksRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesTasksRetrieve(ctx context.Context, akvintegrationPk string, akvpushPk string, id string) ApiIntegrationsAzureKeyVaultPushesTasksRetrieveRequest {
	return ApiIntegrationsAzureKeyVaultPushesTasksRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		akvpushPk:        akvpushPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AzureKeyVaultPushTask
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesTasksRetrieveExecute(r ApiIntegrationsAzureKeyVaultPushesTasksRetrieveRequest) (*AzureKeyVaultPushTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultPushTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPushesTasksRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pushes/{akvpush_pk}/tasks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"akvpush_pk"+"}", url.PathEscape(parameterToString(r.akvpushPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest struct {
	ctx                context.Context
	ApiService         *IntegrationsApiService
	akvintegrationPk   string
	akvpushPk          string
	akvpushtaskPk      string
	fqn                *string
	modifiedAt         *time.Time
	modifiedAtGte      *time.Time
	modifiedAtLte      *time.Time
	operation          *string
	ordering           *string
	page               *int32
	pageSize           *int32
	success            *bool
	venueId            *string
	venueIdIcontains   *string
	venueName          *string
	venueNameIcontains *string
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) Fqn(fqn string) ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest {
	r.fqn = &fqn
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) ModifiedAt(modifiedAt time.Time) ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest {
	r.modifiedAt = &modifiedAt
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) ModifiedAtLte(modifiedAtLte time.Time) ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest {
	r.modifiedAtLte = &modifiedAtLte
	return r
}

// The operation performed, if any.  When the operation is an update, there may be additional details in the success_detail field to describe the change.  When the project is filled in but the environment and parameterare not, the operation is on the project.  When the environmentis filled in but the project and parameter are not, the operationis on the environment.  When the project and parameter are filledin but the environment is not, the operation is on the parameter.When all three are filled in, the operation is on the value ofthe parameter of the project in the specified environment.
func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) Operation(operation string) ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest {
	r.operation = &operation
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) Ordering(ordering string) ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) Page(page int32) ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) PageSize(pageSize int32) ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) Success(success bool) ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest {
	r.success = &success
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) VenueId(venueId string) ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest {
	r.venueId = &venueId
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) VenueIdIcontains(venueIdIcontains string) ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest {
	r.venueIdIcontains = &venueIdIcontains
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) VenueName(venueName string) ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest {
	r.venueName = &venueName
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) VenueNameIcontains(venueNameIcontains string) ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest {
	r.venueNameIcontains = &venueNameIcontains
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) Execute() (*PaginatedAzureKeyVaultPushTaskStepList, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPushesTasksStepsListExecute(r)
}

/*
IntegrationsAzureKeyVaultPushesTasksStepsList Method for IntegrationsAzureKeyVaultPushesTasksStepsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param akvpushPk
 @param akvpushtaskPk
 @return ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesTasksStepsList(ctx context.Context, akvintegrationPk string, akvpushPk string, akvpushtaskPk string) ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest {
	return ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		akvpushPk:        akvpushPk,
		akvpushtaskPk:    akvpushtaskPk,
	}
}

// Execute executes the request
//  @return PaginatedAzureKeyVaultPushTaskStepList
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesTasksStepsListExecute(r ApiIntegrationsAzureKeyVaultPushesTasksStepsListRequest) (*PaginatedAzureKeyVaultPushTaskStepList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAzureKeyVaultPushTaskStepList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPushesTasksStepsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pushes/{akvpush_pk}/tasks/{akvpushtask_pk}/steps/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"akvpush_pk"+"}", url.PathEscape(parameterToString(r.akvpushPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"akvpushtask_pk"+"}", url.PathEscape(parameterToString(r.akvpushtaskPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fqn != nil {
		localVarQueryParams.Add("fqn", parameterToString(*r.fqn, ""))
	}
	if r.modifiedAt != nil {
		localVarQueryParams.Add("modified_at", parameterToString(*r.modifiedAt, ""))
	}
	if r.modifiedAtGte != nil {
		localVarQueryParams.Add("modified_at__gte", parameterToString(*r.modifiedAtGte, ""))
	}
	if r.modifiedAtLte != nil {
		localVarQueryParams.Add("modified_at__lte", parameterToString(*r.modifiedAtLte, ""))
	}
	if r.operation != nil {
		localVarQueryParams.Add("operation", parameterToString(*r.operation, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.success != nil {
		localVarQueryParams.Add("success", parameterToString(*r.success, ""))
	}
	if r.venueId != nil {
		localVarQueryParams.Add("venue_id", parameterToString(*r.venueId, ""))
	}
	if r.venueIdIcontains != nil {
		localVarQueryParams.Add("venue_id__icontains", parameterToString(*r.venueIdIcontains, ""))
	}
	if r.venueName != nil {
		localVarQueryParams.Add("venue_name", parameterToString(*r.venueName, ""))
	}
	if r.venueNameIcontains != nil {
		localVarQueryParams.Add("venue_name__icontains", parameterToString(*r.venueNameIcontains, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPushesTasksStepsRetrieveRequest struct {
	ctx              context.Context
	ApiService       *IntegrationsApiService
	akvintegrationPk string
	akvpushPk        string
	akvpushtaskPk    string
	id               string
}

func (r ApiIntegrationsAzureKeyVaultPushesTasksStepsRetrieveRequest) Execute() (*AzureKeyVaultPushTaskStep, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPushesTasksStepsRetrieveExecute(r)
}

/*
IntegrationsAzureKeyVaultPushesTasksStepsRetrieve Method for IntegrationsAzureKeyVaultPushesTasksStepsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param akvpushPk
 @param akvpushtaskPk
 @param id
 @return ApiIntegrationsAzureKeyVaultPushesTasksStepsRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesTasksStepsRetrieve(ctx context.Context, akvintegrationPk string, akvpushPk string, akvpushtaskPk string, id string) ApiIntegrationsAzureKeyVaultPushesTasksStepsRetrieveRequest {
	return ApiIntegrationsAzureKeyVaultPushesTasksStepsRetrieveRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		akvpushPk:        akvpushPk,
		akvpushtaskPk:    akvpushtaskPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AzureKeyVaultPushTaskStep
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesTasksStepsRetrieveExecute(r ApiIntegrationsAzureKeyVaultPushesTasksStepsRetrieveRequest) (*AzureKeyVaultPushTaskStep, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultPushTaskStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPushesTasksStepsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pushes/{akvpush_pk}/tasks/{akvpushtask_pk}/steps/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"akvpush_pk"+"}", url.PathEscape(parameterToString(r.akvpushPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"akvpushtask_pk"+"}", url.PathEscape(parameterToString(r.akvpushtaskPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultPushesUpdateRequest struct {
	ctx                     context.Context
	ApiService              *IntegrationsApiService
	akvintegrationPk        string
	id                      string
	azureKeyVaultPushUpdate *AzureKeyVaultPushUpdate
}

func (r ApiIntegrationsAzureKeyVaultPushesUpdateRequest) AzureKeyVaultPushUpdate(azureKeyVaultPushUpdate AzureKeyVaultPushUpdate) ApiIntegrationsAzureKeyVaultPushesUpdateRequest {
	r.azureKeyVaultPushUpdate = &azureKeyVaultPushUpdate
	return r
}

func (r ApiIntegrationsAzureKeyVaultPushesUpdateRequest) Execute() (*AzureKeyVaultPushUpdate, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultPushesUpdateExecute(r)
}

/*
IntegrationsAzureKeyVaultPushesUpdate Method for IntegrationsAzureKeyVaultPushesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param akvintegrationPk
 @param id
 @return ApiIntegrationsAzureKeyVaultPushesUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesUpdate(ctx context.Context, akvintegrationPk string, id string) ApiIntegrationsAzureKeyVaultPushesUpdateRequest {
	return ApiIntegrationsAzureKeyVaultPushesUpdateRequest{
		ApiService:       a,
		ctx:              ctx,
		akvintegrationPk: akvintegrationPk,
		id:               id,
	}
}

// Execute executes the request
//  @return AzureKeyVaultPushUpdate
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultPushesUpdateExecute(r ApiIntegrationsAzureKeyVaultPushesUpdateRequest) (*AzureKeyVaultPushUpdate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultPushUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultPushesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{akvintegration_pk}/pushes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"akvintegration_pk"+"}", url.PathEscape(parameterToString(r.akvintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.azureKeyVaultPushUpdate == nil {
		return localVarReturnValue, nil, reportError("azureKeyVaultPushUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.azureKeyVaultPushUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultRetrieveRequest struct {
	ctx           context.Context
	ApiService    *IntegrationsApiService
	id            string
	refreshStatus *bool
}

// Trigger a refresh of the integration status before returning the details.
func (r ApiIntegrationsAzureKeyVaultRetrieveRequest) RefreshStatus(refreshStatus bool) ApiIntegrationsAzureKeyVaultRetrieveRequest {
	r.refreshStatus = &refreshStatus
	return r
}

func (r ApiIntegrationsAzureKeyVaultRetrieveRequest) Execute() (*AzureKeyVaultIntegration, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultRetrieveExecute(r)
}

/*
IntegrationsAzureKeyVaultRetrieve Get details of an Azure Key Vault Integration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsAzureKeyVaultRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultRetrieve(ctx context.Context, id string) ApiIntegrationsAzureKeyVaultRetrieveRequest {
	return ApiIntegrationsAzureKeyVaultRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return AzureKeyVaultIntegration
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultRetrieveExecute(r ApiIntegrationsAzureKeyVaultRetrieveRequest) (*AzureKeyVaultIntegration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.refreshStatus != nil {
		localVarQueryParams.Add("refresh_status", parameterToString(*r.refreshStatus, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultScanCreateRequest struct {
	ctx                          context.Context
	ApiService                   *IntegrationsApiService
	id                           string
	azureKeyVaultIntegrationScan *AzureKeyVaultIntegrationScan
}

func (r ApiIntegrationsAzureKeyVaultScanCreateRequest) AzureKeyVaultIntegrationScan(azureKeyVaultIntegrationScan AzureKeyVaultIntegrationScan) ApiIntegrationsAzureKeyVaultScanCreateRequest {
	r.azureKeyVaultIntegrationScan = &azureKeyVaultIntegrationScan
	return r
}

func (r ApiIntegrationsAzureKeyVaultScanCreateRequest) Execute() (*DiscoveryResult, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultScanCreateExecute(r)
}

/*
IntegrationsAzureKeyVaultScanCreate Evaluate a potential pull pattern and understand what it will match.

Probe a region and service using a pattern matching string that can be used in pull actions.  This allows the pattern match to be checked for correctness and preview what will match during creation of the string.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsAzureKeyVaultScanCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultScanCreate(ctx context.Context, id string) ApiIntegrationsAzureKeyVaultScanCreateRequest {
	return ApiIntegrationsAzureKeyVaultScanCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return DiscoveryResult
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultScanCreateExecute(r ApiIntegrationsAzureKeyVaultScanCreateRequest) (*DiscoveryResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DiscoveryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultScanCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{id}/scan/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.azureKeyVaultIntegrationScan == nil {
		return localVarReturnValue, nil, reportError("azureKeyVaultIntegrationScan is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.azureKeyVaultIntegrationScan
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsAzureKeyVaultUpdateRequest struct {
	ctx                      context.Context
	ApiService               *IntegrationsApiService
	id                       string
	azureKeyVaultIntegration *AzureKeyVaultIntegration
}

func (r ApiIntegrationsAzureKeyVaultUpdateRequest) AzureKeyVaultIntegration(azureKeyVaultIntegration AzureKeyVaultIntegration) ApiIntegrationsAzureKeyVaultUpdateRequest {
	r.azureKeyVaultIntegration = &azureKeyVaultIntegration
	return r
}

func (r ApiIntegrationsAzureKeyVaultUpdateRequest) Execute() (*AzureKeyVaultIntegration, *http.Response, error) {
	return r.ApiService.IntegrationsAzureKeyVaultUpdateExecute(r)
}

/*
IntegrationsAzureKeyVaultUpdate Method for IntegrationsAzureKeyVaultUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsAzureKeyVaultUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultUpdate(ctx context.Context, id string) ApiIntegrationsAzureKeyVaultUpdateRequest {
	return ApiIntegrationsAzureKeyVaultUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return AzureKeyVaultIntegration
func (a *IntegrationsApiService) IntegrationsAzureKeyVaultUpdateExecute(r ApiIntegrationsAzureKeyVaultUpdateRequest) (*AzureKeyVaultIntegration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AzureKeyVaultIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsAzureKeyVaultUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/azure/key_vault/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.azureKeyVaultIntegration
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsExploreListRequest struct {
	ctx        context.Context
	ApiService *IntegrationsApiService
	fqn        *string
	jmes       *string
	ordering   *string
	page       *int32
	pageSize   *int32
}

// FQN (URL-like) for third-party integration.
func (r ApiIntegrationsExploreListRequest) Fqn(fqn string) ApiIntegrationsExploreListRequest {
	r.fqn = &fqn
	return r
}

// JMES-path qualifier (key within file)
func (r ApiIntegrationsExploreListRequest) Jmes(jmes string) ApiIntegrationsExploreListRequest {
	r.jmes = &jmes
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsExploreListRequest) Ordering(ordering string) ApiIntegrationsExploreListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsExploreListRequest) Page(page int32) ApiIntegrationsExploreListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsExploreListRequest) PageSize(pageSize int32) ApiIntegrationsExploreListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsExploreListRequest) Execute() (*PaginatedIntegrationNodeList, *http.Response, error) {
	return r.ApiService.IntegrationsExploreListExecute(r)
}

/*
IntegrationsExploreList Retrieve third-party integration data for the specified FQN.

### Description ###

Queries a third-party integration to retrieve the data specified by the FQN.

You can start exploring by not specifying an 'fqn', which will return a list of FQNs for the existing third-party integrations. Third-party integrations can be configured via the Integrations section of the web application.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntegrationsExploreListRequest
*/
func (a *IntegrationsApiService) IntegrationsExploreList(ctx context.Context) ApiIntegrationsExploreListRequest {
	return ApiIntegrationsExploreListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedIntegrationNodeList
func (a *IntegrationsApiService) IntegrationsExploreListExecute(r ApiIntegrationsExploreListRequest) (*PaginatedIntegrationNodeList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedIntegrationNodeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsExploreList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/explore/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fqn != nil {
		localVarQueryParams.Add("fqn", parameterToString(*r.fqn, ""))
	}
	if r.jmes != nil {
		localVarQueryParams.Add("jmes", parameterToString(*r.jmes, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsGithubCreateRequest struct {
	ctx                     context.Context
	ApiService              *IntegrationsApiService
	gitHubIntegrationCreate *GitHubIntegrationCreate
}

func (r ApiIntegrationsGithubCreateRequest) GitHubIntegrationCreate(gitHubIntegrationCreate GitHubIntegrationCreate) ApiIntegrationsGithubCreateRequest {
	r.gitHubIntegrationCreate = &gitHubIntegrationCreate
	return r
}

func (r ApiIntegrationsGithubCreateRequest) Execute() (*GitHubIntegration, *http.Response, error) {
	return r.ApiService.IntegrationsGithubCreateExecute(r)
}

/*
IntegrationsGithubCreate Establishes a GitHub Integration.

### Description ###

Establishes a GitHub Integration in your CloudTruth organization.

### Pre-Conditions ###

- The user must be an Administrator or Owner of your organization.
- A GitHub Integration with the `installation_id` cannot
already exist in this organization.
- The user must first install the CloudTruth GitHub Application in
their GitHub organization and obtain the `installation_id` of the
application in order to create the integration.

### Initiating the GitHub Application Installation ###

- Go to `https://github.com/apps/GITHUB_APP_NAME/installations/new?state=<bearer_token>`
- On successful installation the browser will return to
`https://APP_URL/app_setup/github` (configured in ctops/bin/github*)
and provide the `installation_id` in the URI.
- POST to this api to verify and establish the integration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntegrationsGithubCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubCreate(ctx context.Context) ApiIntegrationsGithubCreateRequest {
	return ApiIntegrationsGithubCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GitHubIntegration
func (a *IntegrationsApiService) IntegrationsGithubCreateExecute(r ApiIntegrationsGithubCreateRequest) (*GitHubIntegration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GitHubIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitHubIntegrationCreate == nil {
		return localVarReturnValue, nil, reportError("gitHubIntegrationCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gitHubIntegrationCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsGithubDestroyRequest struct {
	ctx        context.Context
	ApiService *IntegrationsApiService
	id         string
	inUse      *string
}

// (Optional) Desired behavior if the integration has in-use values.  - &#x60;fail&#x60; will return HTTP error 409 if there are any values using the integration. - &#x60;leave&#x60; (default) will leave values in place and future queries may fail; you can control future value query behavior with the &#x60;lookup_error&#x60; query parameter on those requests. - &#x60;remove&#x60; will remove the all values using the integration when the integration is removed.
func (r ApiIntegrationsGithubDestroyRequest) InUse(inUse string) ApiIntegrationsGithubDestroyRequest {
	r.inUse = &inUse
	return r
}

func (r ApiIntegrationsGithubDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationsGithubDestroyExecute(r)
}

/*
IntegrationsGithubDestroy Delete a GitHub integration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsGithubDestroyRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubDestroy(ctx context.Context, id string) ApiIntegrationsGithubDestroyRequest {
	return ApiIntegrationsGithubDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsGithubDestroyExecute(r ApiIntegrationsGithubDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inUse != nil {
		localVarQueryParams.Add("in_use", parameterToString(*r.inUse, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsGithubListRequest struct {
	ctx                context.Context
	ApiService         *IntegrationsApiService
	ghOrganizationSlug *string
	ordering           *string
	page               *int32
	pageSize           *int32
}

func (r ApiIntegrationsGithubListRequest) GhOrganizationSlug(ghOrganizationSlug string) ApiIntegrationsGithubListRequest {
	r.ghOrganizationSlug = &ghOrganizationSlug
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsGithubListRequest) Ordering(ordering string) ApiIntegrationsGithubListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsGithubListRequest) Page(page int32) ApiIntegrationsGithubListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsGithubListRequest) PageSize(pageSize int32) ApiIntegrationsGithubListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsGithubListRequest) Execute() (*PaginatedGitHubIntegrationList, *http.Response, error) {
	return r.ApiService.IntegrationsGithubListExecute(r)
}

/*
IntegrationsGithubList Method for IntegrationsGithubList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntegrationsGithubListRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubList(ctx context.Context) ApiIntegrationsGithubListRequest {
	return ApiIntegrationsGithubListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedGitHubIntegrationList
func (a *IntegrationsApiService) IntegrationsGithubListExecute(r ApiIntegrationsGithubListRequest) (*PaginatedGitHubIntegrationList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedGitHubIntegrationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ghOrganizationSlug != nil {
		localVarQueryParams.Add("gh_organization_slug", parameterToString(*r.ghOrganizationSlug, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsGithubPullsListRequest struct {
	ctx                  context.Context
	ApiService           *IntegrationsApiService
	githubintegrationPk  string
	descriptionIcontains *string
	name                 *string
	nameIcontains        *string
	ordering             *string
	page                 *int32
	pageSize             *int32
}

func (r ApiIntegrationsGithubPullsListRequest) DescriptionIcontains(descriptionIcontains string) ApiIntegrationsGithubPullsListRequest {
	r.descriptionIcontains = &descriptionIcontains
	return r
}

func (r ApiIntegrationsGithubPullsListRequest) Name(name string) ApiIntegrationsGithubPullsListRequest {
	r.name = &name
	return r
}

func (r ApiIntegrationsGithubPullsListRequest) NameIcontains(nameIcontains string) ApiIntegrationsGithubPullsListRequest {
	r.nameIcontains = &nameIcontains
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsGithubPullsListRequest) Ordering(ordering string) ApiIntegrationsGithubPullsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsGithubPullsListRequest) Page(page int32) ApiIntegrationsGithubPullsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsGithubPullsListRequest) PageSize(pageSize int32) ApiIntegrationsGithubPullsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsGithubPullsListRequest) Execute() (*PaginatedGitHubPullList, *http.Response, error) {
	return r.ApiService.IntegrationsGithubPullsListExecute(r)
}

/*
IntegrationsGithubPullsList Method for IntegrationsGithubPullsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param githubintegrationPk
 @return ApiIntegrationsGithubPullsListRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubPullsList(ctx context.Context, githubintegrationPk string) ApiIntegrationsGithubPullsListRequest {
	return ApiIntegrationsGithubPullsListRequest{
		ApiService:          a,
		ctx:                 ctx,
		githubintegrationPk: githubintegrationPk,
	}
}

// Execute executes the request
//  @return PaginatedGitHubPullList
func (a *IntegrationsApiService) IntegrationsGithubPullsListExecute(r ApiIntegrationsGithubPullsListRequest) (*PaginatedGitHubPullList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedGitHubPullList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubPullsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/{githubintegration_pk}/pulls/"
	localVarPath = strings.Replace(localVarPath, "{"+"githubintegration_pk"+"}", url.PathEscape(parameterToString(r.githubintegrationPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.descriptionIcontains != nil {
		localVarQueryParams.Add("description__icontains", parameterToString(*r.descriptionIcontains, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameIcontains != nil {
		localVarQueryParams.Add("name__icontains", parameterToString(*r.nameIcontains, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsGithubPullsPartialUpdateRequest struct {
	ctx                 context.Context
	ApiService          *IntegrationsApiService
	githubintegrationPk string
	id                  string
	patchedGitHubPull   *PatchedGitHubPull
}

func (r ApiIntegrationsGithubPullsPartialUpdateRequest) PatchedGitHubPull(patchedGitHubPull PatchedGitHubPull) ApiIntegrationsGithubPullsPartialUpdateRequest {
	r.patchedGitHubPull = &patchedGitHubPull
	return r
}

func (r ApiIntegrationsGithubPullsPartialUpdateRequest) Execute() (*GitHubPull, *http.Response, error) {
	return r.ApiService.IntegrationsGithubPullsPartialUpdateExecute(r)
}

/*
IntegrationsGithubPullsPartialUpdate Method for IntegrationsGithubPullsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param githubintegrationPk
 @param id
 @return ApiIntegrationsGithubPullsPartialUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubPullsPartialUpdate(ctx context.Context, githubintegrationPk string, id string) ApiIntegrationsGithubPullsPartialUpdateRequest {
	return ApiIntegrationsGithubPullsPartialUpdateRequest{
		ApiService:          a,
		ctx:                 ctx,
		githubintegrationPk: githubintegrationPk,
		id:                  id,
	}
}

// Execute executes the request
//  @return GitHubPull
func (a *IntegrationsApiService) IntegrationsGithubPullsPartialUpdateExecute(r ApiIntegrationsGithubPullsPartialUpdateRequest) (*GitHubPull, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GitHubPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubPullsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/{githubintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"githubintegration_pk"+"}", url.PathEscape(parameterToString(r.githubintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedGitHubPull
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsGithubPullsRetrieveRequest struct {
	ctx                 context.Context
	ApiService          *IntegrationsApiService
	githubintegrationPk string
	id                  string
}

func (r ApiIntegrationsGithubPullsRetrieveRequest) Execute() (*GitHubPull, *http.Response, error) {
	return r.ApiService.IntegrationsGithubPullsRetrieveExecute(r)
}

/*
IntegrationsGithubPullsRetrieve Method for IntegrationsGithubPullsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param githubintegrationPk
 @param id
 @return ApiIntegrationsGithubPullsRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubPullsRetrieve(ctx context.Context, githubintegrationPk string, id string) ApiIntegrationsGithubPullsRetrieveRequest {
	return ApiIntegrationsGithubPullsRetrieveRequest{
		ApiService:          a,
		ctx:                 ctx,
		githubintegrationPk: githubintegrationPk,
		id:                  id,
	}
}

// Execute executes the request
//  @return GitHubPull
func (a *IntegrationsApiService) IntegrationsGithubPullsRetrieveExecute(r ApiIntegrationsGithubPullsRetrieveRequest) (*GitHubPull, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GitHubPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubPullsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/{githubintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"githubintegration_pk"+"}", url.PathEscape(parameterToString(r.githubintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsGithubPullsSyncCreateRequest struct {
	ctx                 context.Context
	ApiService          *IntegrationsApiService
	githubintegrationPk string
	id                  string
	gitHubPull          *GitHubPull
}

func (r ApiIntegrationsGithubPullsSyncCreateRequest) GitHubPull(gitHubPull GitHubPull) ApiIntegrationsGithubPullsSyncCreateRequest {
	r.gitHubPull = &gitHubPull
	return r
}

func (r ApiIntegrationsGithubPullsSyncCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationsGithubPullsSyncCreateExecute(r)
}

/*
IntegrationsGithubPullsSyncCreate Method for IntegrationsGithubPullsSyncCreate

Enqueue a pull synchronization task for mapped external values accessible with this integration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param githubintegrationPk
 @param id
 @return ApiIntegrationsGithubPullsSyncCreateRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubPullsSyncCreate(ctx context.Context, githubintegrationPk string, id string) ApiIntegrationsGithubPullsSyncCreateRequest {
	return ApiIntegrationsGithubPullsSyncCreateRequest{
		ApiService:          a,
		ctx:                 ctx,
		githubintegrationPk: githubintegrationPk,
		id:                  id,
	}
}

// Execute executes the request
func (a *IntegrationsApiService) IntegrationsGithubPullsSyncCreateExecute(r ApiIntegrationsGithubPullsSyncCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubPullsSyncCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/{githubintegration_pk}/pulls/{id}/sync/"
	localVarPath = strings.Replace(localVarPath, "{"+"githubintegration_pk"+"}", url.PathEscape(parameterToString(r.githubintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitHubPull == nil {
		return nil, reportError("gitHubPull is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gitHubPull
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsGithubPullsTasksListRequest struct {
	ctx                 context.Context
	ApiService          *IntegrationsApiService
	githubintegrationPk string
	githubpullPk        string
	modifiedAt          *time.Time
	modifiedAtGte       *time.Time
	modifiedAtLte       *time.Time
	ordering            *string
	page                *int32
	pageSize            *int32
	state               *string
}

func (r ApiIntegrationsGithubPullsTasksListRequest) ModifiedAt(modifiedAt time.Time) ApiIntegrationsGithubPullsTasksListRequest {
	r.modifiedAt = &modifiedAt
	return r
}

func (r ApiIntegrationsGithubPullsTasksListRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiIntegrationsGithubPullsTasksListRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}

func (r ApiIntegrationsGithubPullsTasksListRequest) ModifiedAtLte(modifiedAtLte time.Time) ApiIntegrationsGithubPullsTasksListRequest {
	r.modifiedAtLte = &modifiedAtLte
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsGithubPullsTasksListRequest) Ordering(ordering string) ApiIntegrationsGithubPullsTasksListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsGithubPullsTasksListRequest) Page(page int32) ApiIntegrationsGithubPullsTasksListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsGithubPullsTasksListRequest) PageSize(pageSize int32) ApiIntegrationsGithubPullsTasksListRequest {
	r.pageSize = &pageSize
	return r
}

// The current state of this task.
func (r ApiIntegrationsGithubPullsTasksListRequest) State(state string) ApiIntegrationsGithubPullsTasksListRequest {
	r.state = &state
	return r
}

func (r ApiIntegrationsGithubPullsTasksListRequest) Execute() (*PaginatedGitHubPullTaskList, *http.Response, error) {
	return r.ApiService.IntegrationsGithubPullsTasksListExecute(r)
}

/*
IntegrationsGithubPullsTasksList Method for IntegrationsGithubPullsTasksList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param githubintegrationPk
 @param githubpullPk
 @return ApiIntegrationsGithubPullsTasksListRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubPullsTasksList(ctx context.Context, githubintegrationPk string, githubpullPk string) ApiIntegrationsGithubPullsTasksListRequest {
	return ApiIntegrationsGithubPullsTasksListRequest{
		ApiService:          a,
		ctx:                 ctx,
		githubintegrationPk: githubintegrationPk,
		githubpullPk:        githubpullPk,
	}
}

// Execute executes the request
//  @return PaginatedGitHubPullTaskList
func (a *IntegrationsApiService) IntegrationsGithubPullsTasksListExecute(r ApiIntegrationsGithubPullsTasksListRequest) (*PaginatedGitHubPullTaskList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedGitHubPullTaskList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubPullsTasksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/{githubintegration_pk}/pulls/{githubpull_pk}/tasks/"
	localVarPath = strings.Replace(localVarPath, "{"+"githubintegration_pk"+"}", url.PathEscape(parameterToString(r.githubintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"githubpull_pk"+"}", url.PathEscape(parameterToString(r.githubpullPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.modifiedAt != nil {
		localVarQueryParams.Add("modified_at", parameterToString(*r.modifiedAt, ""))
	}
	if r.modifiedAtGte != nil {
		localVarQueryParams.Add("modified_at__gte", parameterToString(*r.modifiedAtGte, ""))
	}
	if r.modifiedAtLte != nil {
		localVarQueryParams.Add("modified_at__lte", parameterToString(*r.modifiedAtLte, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsGithubPullsTasksRetrieveRequest struct {
	ctx                 context.Context
	ApiService          *IntegrationsApiService
	githubintegrationPk string
	githubpullPk        string
	id                  string
}

func (r ApiIntegrationsGithubPullsTasksRetrieveRequest) Execute() (*GitHubPullTask, *http.Response, error) {
	return r.ApiService.IntegrationsGithubPullsTasksRetrieveExecute(r)
}

/*
IntegrationsGithubPullsTasksRetrieve Method for IntegrationsGithubPullsTasksRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param githubintegrationPk
 @param githubpullPk
 @param id
 @return ApiIntegrationsGithubPullsTasksRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubPullsTasksRetrieve(ctx context.Context, githubintegrationPk string, githubpullPk string, id string) ApiIntegrationsGithubPullsTasksRetrieveRequest {
	return ApiIntegrationsGithubPullsTasksRetrieveRequest{
		ApiService:          a,
		ctx:                 ctx,
		githubintegrationPk: githubintegrationPk,
		githubpullPk:        githubpullPk,
		id:                  id,
	}
}

// Execute executes the request
//  @return GitHubPullTask
func (a *IntegrationsApiService) IntegrationsGithubPullsTasksRetrieveExecute(r ApiIntegrationsGithubPullsTasksRetrieveRequest) (*GitHubPullTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GitHubPullTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubPullsTasksRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/{githubintegration_pk}/pulls/{githubpull_pk}/tasks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"githubintegration_pk"+"}", url.PathEscape(parameterToString(r.githubintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"githubpull_pk"+"}", url.PathEscape(parameterToString(r.githubpullPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsGithubPullsTasksStepsListRequest struct {
	ctx                 context.Context
	ApiService          *IntegrationsApiService
	githubintegrationPk string
	githubpullPk        string
	githubpulltaskPk    string
	fqn                 *string
	modifiedAt          *time.Time
	modifiedAtGte       *time.Time
	modifiedAtLte       *time.Time
	operation           *string
	ordering            *string
	page                *int32
	pageSize            *int32
	success             *bool
	venueId             *string
	venueIdIcontains    *string
	venueName           *string
	venueNameIcontains  *string
}

func (r ApiIntegrationsGithubPullsTasksStepsListRequest) Fqn(fqn string) ApiIntegrationsGithubPullsTasksStepsListRequest {
	r.fqn = &fqn
	return r
}

func (r ApiIntegrationsGithubPullsTasksStepsListRequest) ModifiedAt(modifiedAt time.Time) ApiIntegrationsGithubPullsTasksStepsListRequest {
	r.modifiedAt = &modifiedAt
	return r
}

func (r ApiIntegrationsGithubPullsTasksStepsListRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiIntegrationsGithubPullsTasksStepsListRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}

func (r ApiIntegrationsGithubPullsTasksStepsListRequest) ModifiedAtLte(modifiedAtLte time.Time) ApiIntegrationsGithubPullsTasksStepsListRequest {
	r.modifiedAtLte = &modifiedAtLte
	return r
}

// The operation performed, if any.  When the operation is an update, there may be additional details in the success_detail field to describe the change.  When the project is filled in but the environment and parameterare not, the operation is on the project.  When the environmentis filled in but the project and parameter are not, the operationis on the environment.  When the project and parameter are filledin but the environment is not, the operation is on the parameter.When all three are filled in, the operation is on the value ofthe parameter of the project in the specified environment.
func (r ApiIntegrationsGithubPullsTasksStepsListRequest) Operation(operation string) ApiIntegrationsGithubPullsTasksStepsListRequest {
	r.operation = &operation
	return r
}

// Which field to use when ordering the results.
func (r ApiIntegrationsGithubPullsTasksStepsListRequest) Ordering(ordering string) ApiIntegrationsGithubPullsTasksStepsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiIntegrationsGithubPullsTasksStepsListRequest) Page(page int32) ApiIntegrationsGithubPullsTasksStepsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiIntegrationsGithubPullsTasksStepsListRequest) PageSize(pageSize int32) ApiIntegrationsGithubPullsTasksStepsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiIntegrationsGithubPullsTasksStepsListRequest) Success(success bool) ApiIntegrationsGithubPullsTasksStepsListRequest {
	r.success = &success
	return r
}

func (r ApiIntegrationsGithubPullsTasksStepsListRequest) VenueId(venueId string) ApiIntegrationsGithubPullsTasksStepsListRequest {
	r.venueId = &venueId
	return r
}

func (r ApiIntegrationsGithubPullsTasksStepsListRequest) VenueIdIcontains(venueIdIcontains string) ApiIntegrationsGithubPullsTasksStepsListRequest {
	r.venueIdIcontains = &venueIdIcontains
	return r
}

func (r ApiIntegrationsGithubPullsTasksStepsListRequest) VenueName(venueName string) ApiIntegrationsGithubPullsTasksStepsListRequest {
	r.venueName = &venueName
	return r
}

func (r ApiIntegrationsGithubPullsTasksStepsListRequest) VenueNameIcontains(venueNameIcontains string) ApiIntegrationsGithubPullsTasksStepsListRequest {
	r.venueNameIcontains = &venueNameIcontains
	return r
}

func (r ApiIntegrationsGithubPullsTasksStepsListRequest) Execute() (*PaginatedGitHubPullTaskStepList, *http.Response, error) {
	return r.ApiService.IntegrationsGithubPullsTasksStepsListExecute(r)
}

/*
IntegrationsGithubPullsTasksStepsList Method for IntegrationsGithubPullsTasksStepsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param githubintegrationPk
 @param githubpullPk
 @param githubpulltaskPk
 @return ApiIntegrationsGithubPullsTasksStepsListRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubPullsTasksStepsList(ctx context.Context, githubintegrationPk string, githubpullPk string, githubpulltaskPk string) ApiIntegrationsGithubPullsTasksStepsListRequest {
	return ApiIntegrationsGithubPullsTasksStepsListRequest{
		ApiService:          a,
		ctx:                 ctx,
		githubintegrationPk: githubintegrationPk,
		githubpullPk:        githubpullPk,
		githubpulltaskPk:    githubpulltaskPk,
	}
}

// Execute executes the request
//  @return PaginatedGitHubPullTaskStepList
func (a *IntegrationsApiService) IntegrationsGithubPullsTasksStepsListExecute(r ApiIntegrationsGithubPullsTasksStepsListRequest) (*PaginatedGitHubPullTaskStepList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedGitHubPullTaskStepList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubPullsTasksStepsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/{githubintegration_pk}/pulls/{githubpull_pk}/tasks/{githubpulltask_pk}/steps/"
	localVarPath = strings.Replace(localVarPath, "{"+"githubintegration_pk"+"}", url.PathEscape(parameterToString(r.githubintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"githubpull_pk"+"}", url.PathEscape(parameterToString(r.githubpullPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"githubpulltask_pk"+"}", url.PathEscape(parameterToString(r.githubpulltaskPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fqn != nil {
		localVarQueryParams.Add("fqn", parameterToString(*r.fqn, ""))
	}
	if r.modifiedAt != nil {
		localVarQueryParams.Add("modified_at", parameterToString(*r.modifiedAt, ""))
	}
	if r.modifiedAtGte != nil {
		localVarQueryParams.Add("modified_at__gte", parameterToString(*r.modifiedAtGte, ""))
	}
	if r.modifiedAtLte != nil {
		localVarQueryParams.Add("modified_at__lte", parameterToString(*r.modifiedAtLte, ""))
	}
	if r.operation != nil {
		localVarQueryParams.Add("operation", parameterToString(*r.operation, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.success != nil {
		localVarQueryParams.Add("success", parameterToString(*r.success, ""))
	}
	if r.venueId != nil {
		localVarQueryParams.Add("venue_id", parameterToString(*r.venueId, ""))
	}
	if r.venueIdIcontains != nil {
		localVarQueryParams.Add("venue_id__icontains", parameterToString(*r.venueIdIcontains, ""))
	}
	if r.venueName != nil {
		localVarQueryParams.Add("venue_name", parameterToString(*r.venueName, ""))
	}
	if r.venueNameIcontains != nil {
		localVarQueryParams.Add("venue_name__icontains", parameterToString(*r.venueNameIcontains, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsGithubPullsTasksStepsRetrieveRequest struct {
	ctx                 context.Context
	ApiService          *IntegrationsApiService
	githubintegrationPk string
	githubpullPk        string
	githubpulltaskPk    string
	id                  string
}

func (r ApiIntegrationsGithubPullsTasksStepsRetrieveRequest) Execute() (*GitHubPullTaskStep, *http.Response, error) {
	return r.ApiService.IntegrationsGithubPullsTasksStepsRetrieveExecute(r)
}

/*
IntegrationsGithubPullsTasksStepsRetrieve Method for IntegrationsGithubPullsTasksStepsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param githubintegrationPk
 @param githubpullPk
 @param githubpulltaskPk
 @param id
 @return ApiIntegrationsGithubPullsTasksStepsRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubPullsTasksStepsRetrieve(ctx context.Context, githubintegrationPk string, githubpullPk string, githubpulltaskPk string, id string) ApiIntegrationsGithubPullsTasksStepsRetrieveRequest {
	return ApiIntegrationsGithubPullsTasksStepsRetrieveRequest{
		ApiService:          a,
		ctx:                 ctx,
		githubintegrationPk: githubintegrationPk,
		githubpullPk:        githubpullPk,
		githubpulltaskPk:    githubpulltaskPk,
		id:                  id,
	}
}

// Execute executes the request
//  @return GitHubPullTaskStep
func (a *IntegrationsApiService) IntegrationsGithubPullsTasksStepsRetrieveExecute(r ApiIntegrationsGithubPullsTasksStepsRetrieveRequest) (*GitHubPullTaskStep, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GitHubPullTaskStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubPullsTasksStepsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/{githubintegration_pk}/pulls/{githubpull_pk}/tasks/{githubpulltask_pk}/steps/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"githubintegration_pk"+"}", url.PathEscape(parameterToString(r.githubintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"githubpull_pk"+"}", url.PathEscape(parameterToString(r.githubpullPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"githubpulltask_pk"+"}", url.PathEscape(parameterToString(r.githubpulltaskPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsGithubPullsUpdateRequest struct {
	ctx                 context.Context
	ApiService          *IntegrationsApiService
	githubintegrationPk string
	id                  string
	gitHubPull          *GitHubPull
}

func (r ApiIntegrationsGithubPullsUpdateRequest) GitHubPull(gitHubPull GitHubPull) ApiIntegrationsGithubPullsUpdateRequest {
	r.gitHubPull = &gitHubPull
	return r
}

func (r ApiIntegrationsGithubPullsUpdateRequest) Execute() (*GitHubPull, *http.Response, error) {
	return r.ApiService.IntegrationsGithubPullsUpdateExecute(r)
}

/*
IntegrationsGithubPullsUpdate Method for IntegrationsGithubPullsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param githubintegrationPk
 @param id
 @return ApiIntegrationsGithubPullsUpdateRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubPullsUpdate(ctx context.Context, githubintegrationPk string, id string) ApiIntegrationsGithubPullsUpdateRequest {
	return ApiIntegrationsGithubPullsUpdateRequest{
		ApiService:          a,
		ctx:                 ctx,
		githubintegrationPk: githubintegrationPk,
		id:                  id,
	}
}

// Execute executes the request
//  @return GitHubPull
func (a *IntegrationsApiService) IntegrationsGithubPullsUpdateExecute(r ApiIntegrationsGithubPullsUpdateRequest) (*GitHubPull, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GitHubPull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubPullsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/{githubintegration_pk}/pulls/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"githubintegration_pk"+"}", url.PathEscape(parameterToString(r.githubintegrationPk, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gitHubPull == nil {
		return localVarReturnValue, nil, reportError("gitHubPull is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gitHubPull
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsGithubRetrieveRequest struct {
	ctx           context.Context
	ApiService    *IntegrationsApiService
	id            string
	refreshStatus *bool
}

// Refresh the integration status before returning the details.
func (r ApiIntegrationsGithubRetrieveRequest) RefreshStatus(refreshStatus bool) ApiIntegrationsGithubRetrieveRequest {
	r.refreshStatus = &refreshStatus
	return r
}

func (r ApiIntegrationsGithubRetrieveRequest) Execute() (*GitHubIntegration, *http.Response, error) {
	return r.ApiService.IntegrationsGithubRetrieveExecute(r)
}

/*
IntegrationsGithubRetrieve Get details of a GitHub Integration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIntegrationsGithubRetrieveRequest
*/
func (a *IntegrationsApiService) IntegrationsGithubRetrieve(ctx context.Context, id string) ApiIntegrationsGithubRetrieveRequest {
	return ApiIntegrationsGithubRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return GitHubIntegration
func (a *IntegrationsApiService) IntegrationsGithubRetrieveExecute(r ApiIntegrationsGithubRetrieveRequest) (*GitHubIntegration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GitHubIntegration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsApiService.IntegrationsGithubRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/integrations/github/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.refreshStatus != nil {
		localVarQueryParams.Add("refresh_status", parameterToString(*r.refreshStatus, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["JWTAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
